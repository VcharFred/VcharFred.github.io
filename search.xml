<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hadoop安装及配置]]></title>
    <url>%2FJava%2Fhadoop%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[##一、Hadoop安装及配置服务器防火墙相关命令 #查看状态 service iptables status #关闭防火墙 service iptables stop #查看防火墙开机启动状态 checonfig iptables --list #关闭防火墙开机启动 checonfig iptables off 安装jdk，安装教程参考Centos7安装配置Java环境 下载Hadoop安装包: http://hadoop.apache.org/#Download+Hadoop 安装：将tar包解压即可 tar -zxvf xxx #####配置相关文件进入解压包中的/etc/hadoop目录下 修改hadoop-env.sh文件中JAVA_HOME路径为安装jdk的绝对路径/usr/local/java/jdk1.8.0_181 修改core-site.xml文件如下 &lt;configuration&gt; &lt;!--配置元节点--&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://192.168.31.207:9000/&lt;/value&gt; &lt;/property&gt; &lt;!--配置数据存储节点目录--&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/root/soft/hadoop-2.9.1/tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 修改hdfs-site.xml件如下: &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;!--指定副本数 默认是3--&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/root/soft/hadoop-2.9.1/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/root/soft/hadoop-2.9.1/tmp/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 修改mapred-site.xml件如下: &lt;configuration&gt; &lt;!--配置监控器--&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 修改yarn-site.xml件如下: &lt;configuration&gt; &lt;!--指定YARN的老大：即配置主机地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;192.168.31.207&lt;/value&gt; &lt;/property&gt; &lt;!--配置节点管理模式--&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 配置Hadoop的环境变量，修改 /etc/profile文件 JAVA_HOME=/usr/local/java/jdk1.8.0_181 JRE_HOME=/usr/local/java/jdk1.8.0_181/jre CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib export HADOOP_HOME=/root/soft/hadoop-2.9.1 PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin export PATH JAVA_HOME CLASSPATH HADOOP_HOME #刷新配置文件 source /etc/profile 修改主机名,修改host配置文件(记得重启reboot) vi /etc/sysconfig/network #添加主机名 HOSTNAME=hadoop vi /etc/hosts #添加地址映射 172.30.82.61 hadoop hostname hadoop Hadoop初始化 hadoop namenode -format 进入sbin 启动hadoop #启动dfs start-dfs.sh #启动yarn start-yarn.sh ####测试是否成功浏览器访问 http://hadoop:50070 ####hdfs的shell操作添加文件 hadoop fs -put hadoop-2.9.1.tar.gz hdfs://hadoop:9000/ 下载文件 hadoop fs -get hadoop-2.9.1.tar.gz hdfs://hadoop:9000/hadoop-2.9.1.tar.gz 执行mapreduce;进入share/hadoop/mapreduce hadoop jar hadoop-mapreduce-examples-2.9.1.jar pi 5 5 创建文件夹 #方式一：单机时可以直接/就表示根目录 hadoop fs -mkdir /filename #方式二： hadoop fs -mkdir hdfs://hadoop:9000/filename 修改权限 hadoop fs -chown username:groupname filesrc hadoop fs -chmod 777 filesrc 查看空间大小 hadoop fs -df / hadoop fs -df -h / 查看文件夹或文件大小 hadoop fs -du / hadoop fs -du -s -h /* 删除文件和文件夹 hadoop fs -rm -r /aa/bb ####搭建Hadoop集群搭建无密码登陆配置生成ssh密匙 ssh-keygen -t rsa #拷贝到另一台服务器上 scp id_rsa.pub server2:/home/hadoop #追加公匙,在另一台服务器的.ssh目录下执行 cat ../id_rsa.pub &gt;&gt; ./authorized_keys]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot学习笔记]]></title>
    <url>%2FJava%2Fspring-boot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[Spring boot学习笔记官方地址：https://spring.io/projects ##1. 从hello world 开始 ####1.1 maven 依赖 org.springframework.boot spring-boot-starter-parent 2.0.2.RELEASE org.springframework.boot spring-boot-starter-web ####1.2 编写启动程序 #####1.2.1 方式一 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * &lt;p&gt;Spring boot &quot;hello word&quot;&lt;/p&gt; * @author vchar fred * @version 1.0 * @date 2018/6/12 15:42 */ @RestController//相当于Controller+ResponseBody;即自动是ajax的请求 @EnableAutoConfiguration//spring 会自动装配相关的配置,这个是必须有的 public class SpringBootHello { @RequestMapping(&quot;/&quot;) public String home(){ return &quot;hello word!&quot;; } public static void main(String[] args) throws Exception{ SpringApplication.run(SpringBootHello.class, args); } } 运行main方法，在浏览器中访问：http://localhost:8080/ 即可看到hello word打jar包运行的方法：添加如下maven插件依赖 &lt;build&gt; &lt;plugins&gt; &lt;!--spring boot 打包工具--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 运行maven的 package命令；然后运行 java -jar xxx.jar #####1.2.2 方式二 @SpringBootApplication//这个注解包含了EnableAutoConfiguration；更多的配置可以查看源码 @RestController//相当于Controller+ResponseBody;即自动是ajax的请求 public class SpringBootHello { @RequestMapping(“/“) public String home(){ return “hello word!”; } public static void main(String[] args) throws Exception{ SpringApplication.run(SpringBootHello.class, args); } } @SpringBootApplication 注解源码如下： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)) public @interface SpringBootApplication { //排除自启动项 Class&lt;?&gt;[] exclude() default {}; //排除自动启动的beanName String[] excludeName() default {}; //扫描包 @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;) String[] scanBasePackages() default {}; //扫描类 @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;) Class&lt;?&gt;[] scanBasePackageClasses() default {}; } ##2. log日志 来源:https://blog.csdn.net/king_is_everyone/article/details/53074006 SpringBoot默认是采用logback进行日志处理、Logback是由log4j创始人设计的又一个开源日志组件logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块 ###2.1 logback.xml详情 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- configuration 根节点配置参数说明： scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。配置示例： 120 seconds debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false --&gt; &lt;configuration&gt; &lt;!--contextName 设置日志上下文名称，可以通过%contextName来打印日志上下文名称 每个logger都关联到logger上下文，默认上下文名称为“default”。 但可以使用&lt;contextName&gt;设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改 --&gt; &lt;contextName&gt;spring-boot-demo-log&lt;/contextName&gt; &lt;!--property 可以用来设置变量，可以通过${name}来访问，有以下的属性 name：用于${name}访问的key; value：用于${name}访问的value 例：&lt;property name=&quot;log.path&quot; value=&quot;c:\\logback.log&quot; /&gt; file: 用于指定配置文件的路径，他的作用在于，如果你有多个配置信息的话，可以直接写在配置文件中，然后通过file引入 例：&lt;property file=&quot;src/main/java/resources/conf/log.properties&quot; /&gt; resource: 作用和file一样，但是，它是可以直接从classpath路径下引入配置文件 例：&lt;property resource=&quot;/conf/log.properties&quot; /&gt; --&gt; &lt;property name=&quot;APP_ID&quot; value=&quot;top.vchar.learn.springboot&quot;/&gt; &lt;property name=&quot;LOG_PATH&quot; value=&quot;log&quot;&gt;&lt;/property&gt; &lt;!--appender 格式化日志输出节点 1. 有2个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略[STDOUT/console]和文件输出策略[file]. 2. appender有以下子节点： 2.1 filter: 日志输出拦截器，可以自定义拦截器也可以用系统一些定义好的拦截器 /** * 自定义日志输出拦截器 * @author vf * @date 2016-04-28 3:36 */ public class MyFilter extends Filter&lt;ILoggingEvent&gt; { @Override public FilterReply decide(ILoggingEvent event) { if (event.getMessage().contains(&quot;sample&quot;)) { return FilterReply.ACCEPT; //允许输入串 } else { return FilterReply.DENY; //不允许输出 } } } 系统自带的日志拦截器 例：用ThresholdFilter来过滤掉ERROR级别以下的日志不输出 &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; 2.2 encoder和pattern节点组合用于具体输出的日志格式 2.3 file节点用来指明日志文件的输出位置，可以是绝对路径也可以是相对路径 2.4 rollingPolicy日志回滚策略. 2.4.1 TimeBasedRollingPolicy： 基于时间的回滚策略,有以下子节点 fileNamePattern：必要节点，可以用来设置指定时间的日志归档，例如每天将日志归档成一个zip包 maxHistory： 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件,，例如设置为30的话，则30天之后，旧的日志就会被删除 totalSizeCap： 可选节点，用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志 例： &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${log.path}.%d{yyyy-MM-dd}.zip&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; 2.4.2 SizeAndTimeBasedRollingPolicy 基于日志文件大小的回滚策略。 例： &lt;appender name=&quot;ROLLING&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;mylog.txt&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;mylog-%d{yyyy-MM-dd}.%i.txt&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;totalSizeCap&gt;20GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; --&gt; &lt;!--每个级别的日志配置--&gt; &lt;!-- 控制台输出 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-4relative [%thread] %-5level %logger{35} - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--&lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;&lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;&amp;ndash;&amp;gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;&lt;level&gt;ERROR&lt;/level&gt;&amp;ndash;&amp;gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;&lt;/filter&gt;&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;encoder&gt;--&gt; &lt;!--&lt;pattern&gt;%d{HH:mm:ss.SSS} %contextName [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;--&gt; &lt;!--&lt;/encoder&gt;--&gt; &lt;!--&lt;/appender&gt;--&gt; &lt;!--maxHistory配置了日志在服务器上面只存留几个备份--&gt; &lt;appender name=&quot;FILE_LOG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;file&gt;${LOG_PATH}/${APP_ID}/access.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${LOG_PATH}/${APP_ID}/access.log.%d{yyyy-MM-dd}.zip&lt;/fileNamePattern&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;FILE_DEBUG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;file&gt;${LOG_PATH}/${APP_ID}/access_debug.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${LOG_PATH}/${APP_ID}/access_debug.log.%d{yyyy-MM-dd}.zip&lt;/fileNamePattern&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;FILE_INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;file&gt;${LOG_PATH}/${APP_ID}/access_info.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${LOG_PATH}/${APP_ID}/access_info.log.%d{yyyy-MM-dd}.zip&lt;/fileNamePattern&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;FILE_WARN&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;WARN&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;file&gt;${LOG_PATH}/${APP_ID}/access_warn.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${LOG_PATH}/${APP_ID}/access_warn.log.%d{yyyy-MM-dd}.zip&lt;/fileNamePattern&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;FILE_ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;file&gt;${LOG_PATH}/${APP_ID}/access_error.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${LOG_PATH}/${APP_ID}/access_error.log.%d{yyyy-MM-dd}.zip&lt;/fileNamePattern&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--在生产中往往会因为大量的日志导致io过高，所以通过AsyncAppender进行异步的日志记录。--&gt; &lt;appender name=&quot;ASYNC_LOG&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;64&lt;/queueSize&gt; &lt;appender-ref ref=&quot;FILE_LOG&quot;/&gt; &lt;/appender&gt; &lt;appender name=&quot;ASYNC_LOG&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;64&lt;/queueSize&gt; &lt;appender-ref ref=&quot;FILE_LOG&quot;/&gt; &lt;/appender&gt; &lt;appender name=&quot;ASYNC_LOG_DEBUG&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;64&lt;/queueSize&gt; &lt;appender-ref ref=&quot;FILE_DEBUG&quot;/&gt; &lt;/appender&gt; &lt;appender name=&quot;ASYNC_LOG_INFO&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;64&lt;/queueSize&gt; &lt;appender-ref ref=&quot;FILE_INFO&quot;/&gt; &lt;/appender&gt; &lt;appender name=&quot;ASYNC_LOG_WARN&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;64&lt;/queueSize&gt; &lt;appender-ref ref=&quot;FILE_WARN&quot;/&gt; &lt;/appender&gt; &lt;appender name=&quot;ASYNC_LOG_ERROR&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;64&lt;/queueSize&gt; &lt;appender-ref ref=&quot;FILE_ERROR&quot;/&gt; &lt;/appender&gt; &lt;!--指定root的日志级别，一般来说都会指定到info级别， 因为SpringBoot运行的时候会产生大量的debug日志--&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;!-- appender referenced after it is defined --&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;appender-ref ref=&quot;ASYNC_LOG&quot;/&gt; &lt;appender-ref ref=&quot;ASYNC_LOG_DEBUG&quot;/&gt; &lt;appender-ref ref=&quot;ASYNC_LOG_INFO&quot;/&gt; &lt;appender-ref ref=&quot;ASYNC_LOG_WARN&quot;/&gt; &lt;appender-ref ref=&quot;ASYNC_LOG_ERROR&quot;/&gt; &lt;/root&gt; &lt;!--定义org.springframework这个包里面输出debug日志、--&gt; &lt;!--一般来说如果使用Mybatis或者hibernate，需要输出SQL都需要通过这里进行配置，输出debug级别的日志--&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;/&gt; &lt;/configuration&gt; ##3.统一异常处理 来源：https://blog.csdn.net/king_is_everyone/article/details/53080851 ####3.1 spring boot 自带的统一异常处理，重新配置异常地址和页面SpringBoot在页面发生异常的时候会自动把请求转到/error; SpringBoot内置了一个BasicErrorController对异常进行统一的处理，这个错误的地址是可以重新配置的。 在resources目录下创建一个application.yaml配置文件；写入如下配置 server: #访问端口号 port: 8082 error: #设置错误路径 path: /test/error 开始编写测试程序 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; /** * &lt;p&gt;测试异常&lt;/p&gt; * * @author vchar fred * @version 1.0 * @date 2018/6/13 11:17 */ @SpringBootApplication @Controller public class TestExceptionController { @RequestMapping(value = &quot;/ajax&quot;) @ResponseBody public String ajaxRequestExceptionTest(int nu){ //传入参数为0时抛出异常 int num = 1/nu; return &quot;this ok &quot;+ num; } @RequestMapping(value = &quot;/htmls&quot;) public String htmlRequestExceptionTest(int nu){ //传入参数为0时抛出异常 int num = 1/nu; return &quot;index&quot;; } //启动 public static void main(String[] args) throws Exception{ SpringApplication.run(TestExceptionController.class); } } 在resources目录下创建templates目录（这个是默认放置模版文件的目录），并分别创建error.ftl和index.ftl 文件。error.ftl文件用于替换spring boot原有的错误页面，index.ftl用于测试页面 由于用到了freemarker，需要添加maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 启动后开始测试 #测试是否可正常访问 http://127.0.0.1:8082/htmls?nu=1 #测试异常页面 http://127.0.0.1:8082/htmls?nu=0 #ajax请求返回的错误提示 { &quot;timestamp&quot;: &quot;2018-06-13T03:55:51.587+0000&quot;, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;message&quot;: &quot;/ by zero&quot;, &quot;path&quot;: &quot;/ajax&quot; } ###3.2 通用Exception处理通过使用@ControllerAdvice来进行统一异常处理，@ExceptionHandler(value = Exception.class)来指定捕获的异常下面针对两种异常进行了特殊处理分别返回页面和json数据，使用这种方式有个局限，无法根据不同的头部返回不同的数据格式，而且无法针对404、403等多种状态进行处理 //异常处理类 @ControllerAdvice public class GlobalExceptionHandler { public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;; @ExceptionHandler(value = CustomException.class) @ResponseBody public ResponseEntity defaultErrorHandler(HttpServletRequest req, CustomException e) throws Exception { return ResponseEntity.ok(&quot;ok&quot;); } @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;, e); mav.addObject(&quot;url&quot;, req.getRequestURL()); mav.setViewName(DEFAULT_ERROR_VIEW); return mav; } } //自定义异常 public class CustomException extends Exception { CustomException(String errorMsg){ super(errorMsg); } } //测试路由 @RequestMapping(value = &quot;/coustom&quot;) public String coustomExceptionTest() throws CustomException { customExce(); return &quot;index&quot;; } private void customExce() throws CustomException { throw new CustomException(&quot;自定义异常&quot;); } ###3.3 自定义BasicErrorController 错误处理在初始介绍哪里提到了BasicErrorController，这个是SpringBoot的默认错误处理，也是一种全局处理方式。咱们可以模仿这种处理方式自定义自己的全局错误处理下面定义了一个自己的BasicErrorController，可以根据自己的需求自定义对应的错误处理。 @ResponseStatus 注解的异常类会被ResponseStatusExceptionResolver 解析 import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.autoconfigure.web.servlet.error.AbstractErrorController; import org.springframework.boot.web.servlet.error.ErrorAttributes; import org.springframework.core.Ordered; import org.springframework.core.annotation.Order; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.MethodArgumentNotValidException; import org.springframework.web.bind.annotation.*; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.NoHandlerFoundException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Date; import java.util.HashMap; import java.util.Map; /** * &lt;p&gt;自定义异常controller&lt;/p&gt; * * @author vchar fred * @version 1.0 * @date 2018/6/13 14:25 */ @Order(Ordered.HIGHEST_PRECEDENCE) @ControllerAdvice @Controller @RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;) public class BasicErrorController extends AbstractErrorController { public BasicErrorController(ErrorAttributes errorAttributes) { super(errorAttributes); } private static final Logger log = LoggerFactory.getLogger(BasicErrorController.class); @Value(&quot;${server.error.path:${error.path:/error}}&quot;) private static String errorPath = &quot;/error&quot;; /** * 500 错误 * @param request * @param response * @param ex * @return * @throws Exception */ @ResponseStatus(code = HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception.class) public ModelAndView serverError(HttpServletRequest request, HttpServletResponse response, Exception ex) throws Exception { return handleViewError(ex.getMessage(), &quot;500&quot;, &quot;error/500&quot;); } /** * 404错误 * @param request * @param response * @param ex * @return * @throws Exception */ @ResponseStatus(code = HttpStatus.NOT_FOUND) @ExceptionHandler(NoHandlerFoundException.class) public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; notFound(HttpServletRequest request, HttpServletResponse response, Exception ex) throws Exception { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;status&quot;, 404); map.put(&quot;msg&quot;, &quot;the resource is not found&quot;); map.put(&quot;exception&quot;, ex.getMessage()); return ResponseEntity.ok(map); } /** * 参数不完整错误. * @param req * @param rsp * @param ex * @return * @throws Exception */ @ResponseStatus(code = HttpStatus.BAD_REQUEST) @ExceptionHandler(MethodArgumentNotValidException.class) public ModelAndView methodArgumentNotValidException(HttpServletRequest req, HttpServletResponse rsp, MethodArgumentNotValidException ex) throws Exception { return handleViewError(ex.getMessage(), &quot;404&quot;, &quot;error/404&quot;); } private ModelAndView handleViewError(String errorStack, String errorMessage, String viewName) { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;exception&quot;, errorStack); mav.addObject(&quot;msg&quot;, errorMessage); mav.addObject(&quot;timestamp&quot;, new Date()); mav.setViewName(viewName); return mav; } @Override public String getErrorPath() { return errorPath; } } 定义文件结构如下: ##4. spring boot中使用redisapplication.yaml配置文件中添加redis如下配置 spring: rdeis: host: 127.0.0.1 port: 6379 timeout: 3000 pool: # 连接池最大连接数（使用负值表示没有限制） max-total: 8 # 连接池最大阻塞等待时间（使用负值表示没有限制） max-wait-millis: -1 # 连接池中的最大空闲连接 max-idle: 8 # 连接池中的最小空闲连接 min-idle: 0 加入需要的依赖包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 注：网上其他有很多教程说引入的是下面这个包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; &lt;/dependency&gt; 但是我在引入时发现当前这个版本中这个包已经无法下载了。 ###4.1 redis 配置方式1，使用默认的因为上面依赖了spring-boot-starter-data-redis,可以使用默认的 org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration 类加载properties文件的配置。它的源码如下： @Configuration protected static class RedisConfiguration { @Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;Object, Object&gt; redisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;Object, Object&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean(StringRedisTemplate.class) public StringRedisTemplate stringRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } } 使用方法 @RestController public class StartServe { @Autowired private StringRedisTemplate template; @Autowired private RedisTemplate&lt;Object, Object&gt; redisTemplate; @RequestMapping(&quot;/redis&quot;) public String redisTest(){ //这两个的是不一样的。因为RedisTemplate&lt;Object,Object&gt; 默认会将对象使用JdkSerializationRedisSerializer进行序列化 redisTemplate.opsForValue().set(&quot;test&quot;, &quot;123456&quot;); template.opsForValue().set(&quot;test&quot;, &quot;abcdef&quot;); return template.opsForValue().get(&quot;test&quot;)+&quot;---|||---&quot;+redisTemplate.opsForValue().get(&quot;test&quot;); } } ###4.2 redis 配置方式2，自己手动配置 ####4.2.1 redis的单机版连接池配置需要加入额外的jar包： &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 编写相关代码： 单机版 import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.jedis.JedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import redis.clients.jedis.JedisPoolConfig; /** * &lt;p&gt;redis 配置&lt;/p&gt; * * @author vchar fred * @version 1.0 * @date 2018/6/13 18:05 */ @Configuration public class RedisConfig { @Value(&quot;${spring.redis.host}&quot;) private String host; @Value(&quot;${spring.redis.port}&quot;) private int port; @Value(&quot;${spring.redis.timeout}&quot;) private int timeout; //@Value(&quot;${spring.redis.password}&quot;) //private String password; @Value(&quot;${spring.redis.pool.max-idle}&quot;) private int maxIdle; @Value(&quot;${spring.redis.pool.min-idle}&quot;) private int minIdle; @Value(&quot;${spring.redis.pool.max-total}&quot;) private int maxTotal; @Value(&quot;${spring.redis.pool.max-wait-millis}&quot;) private int maxWaitMillis; /** * 连接设置 * @return 返回连接工厂 */ @Bean(name = &quot;jedisConnectionFactory&quot;) public JedisConnectionFactory getJedisConnectionFactory(JedisPoolConfig jedisPoolConfig){ JedisConnectionFactory factory = new JedisConnectionFactory(); factory.setHostName(host); factory.setPort(port); //factory.setPassword(&quot;&quot;);//设置认证密码 //factory.setDatabase();//设置库 factory.setTimeout(timeout); factory.setUsePool(true); factory.setPoolConfig(jedisPoolConfig); return factory; } /** * 连接池设置 * @return 返回连接池配置 */ @Bean(name = &quot;jedisPoolConfig&quot;) public JedisPoolConfig getJedisPoolConfig(){ JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(maxTotal); jedisPoolConfig.setMaxIdle(maxIdle); jedisPoolConfig.setMaxWaitMillis(maxWaitMillis); jedisPoolConfig.setMinIdle(minIdle); return jedisPoolConfig; } /** * RedisTemplate&lt;?,?&gt; * @param jedisConnectionFactory JedisConnectionFactory * @return */ @Bean public RedisTemplate&lt;?,?&gt; redisTemplate(JedisConnectionFactory jedisConnectionFactory){ RedisTemplate&lt;?, ?&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(jedisConnectionFactory); //key序列化方式;但是如果方法上有Long等非String类型的话，会报类型转换错误； RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();//Long类型不可以会出现异常信息; redisTemplate.setKeySerializer(redisSerializer); redisTemplate.setHashKeySerializer(redisSerializer); //key序列化方式;但是如果方法上有Long等非String类型的话，会报类型转换错误； redisTemplate.setValueSerializer(redisSerializer); redisTemplate.setHashValueSerializer(redisSerializer); redisTemplate.afterPropertiesSet(); //查看 StringRedisTemplate 的初始化源码，你会发现其实它和上面一样做了的key和value的序列化设置 return redisTemplate; } /** * StringRedisTemplate * @param jedisConnectionFactory JedisConnectionFactory * @return StringRedisTemplate */ @Bean public StringRedisTemplate stringRedisTemplate(JedisConnectionFactory jedisConnectionFactory){ StringRedisTemplate stringRedisTemplate = new StringRedisTemplate(); stringRedisTemplate.setConnectionFactory(jedisConnectionFactory); return stringRedisTemplate; } } 集群版 import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import redis.clients.jedis.HostAndPort; import redis.clients.jedis.JedisCluster; import java.util.HashSet; import java.util.Set; /** * redis集群配置 */ @Configuration //相当于以前的配置文件 public class RedisConfig { @Value(&quot;${spring.redis.cluster.nodes}&quot;) private static String clusterNodes; @Bean(&quot;jedisCluster&quot;) public JedisCluster getJedisCluster(){ String[] cNodes = clusterNodes.split(&quot;,&quot;); Set&lt;HostAndPort&gt; nodes = new HashSet&lt;HostAndPort&gt;(); for (String node: cNodes) { String[] hp = node.split(&quot;:&quot;); nodes.add(new HostAndPort(hp[0],Integer.parseInt(hp[1]))); } //创建redis的集群对象 return new JedisCluster(nodes); } } 使用方式同上面方式一的，这次你会发现他们的key是一样（因为序列化的方式是一样的了）。 另附一个redis配置比较完整的配置文件来源：https://www.cnblogs.com/EasonJim/p/7805665.html 单机版 # REDIS（RedisProperties） # （普通集群，不使用则不用开启）在群集中执行命令时要遵循的最大重定向数目。 # spring.redis.cluster.max-redirects= # （普通集群，不使用则不用开启）以逗号分隔的“主机：端口”对列表进行引导。 # spring.redis.cluster.nodes= # 连接工厂使用的数据库索引。 spring.redis.database=0 # 连接URL，将覆盖主机，端口和密码（用户将被忽略），例如：redis://user:password@example.com:6379 spring.redis.url= # Redis服务器主机。 spring.redis.host=localhost # 登录redis服务器的密码。 spring.redis.password= # 启用SSL支持。 spring.redis.ssl=false # 池在给定时间可以分配的最大连接数。使用负值无限制。 spring.redis.pool.max-total=8 # 池中“空闲”连接的最大数量。使用负值表示无限数量的空闲连接。 spring.redis.pool.max-idle=8 # 连接分配在池被耗尽时抛出异常之前应该阻塞的最长时间量（以毫秒为单位）。使用负值可以无限期地阻止。 spring.redis.pool.max-wait-millis=-1 # 目标为保持在池中的最小空闲连接数。这个设置只有在正面的情况下才有效果。 spring.redis.pool.min-idle=0 # Redis服务器端口。 spring.redis.port=6379 # （哨兵模式，不使用则不用开启）Redis服务器的名称。 # spring.redis.sentinel.master= # （哨兵模式，不使用则不用开启）主机：端口对的逗号分隔列表。 # spring.redis.sentinel.nodes= # 以毫秒为单位的连接超时。 spring.redis.timeout=0 集群版，将下面这2项打开即可。 # （普通集群，不使用则不用开启）在群集中执行命令时要遵循的最大重定向数目。 spring.redis.cluster.max-redirects= # （普通集群，不使用则不用开启）以逗号分隔的“主机：端口”对列表进行引导。 spring.redis.cluster.nodes=127.0.0.1:1001,127.0.0.1:1002 注意：一旦开启了集群模式，那么基于单机的配置就会覆盖。 ##使用到的注解说明注解 | 说明-|:-@EnableAutoConfiguration| spring会自动的猜测你需要的那些配置，智能的帮助你去扫描配置]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础之Linux基础(一)]]></title>
    <url>%2FPython%2Fpython%E5%9F%BA%E7%A1%80%E4%B9%8Blinux%E5%9F%BA%E7%A1%80-%E4%B8%80.html</url>
    <content type="text"><![CDATA[#Linux 基础 ###常用命令 ls 显示当前文件夹下的文件和文件夹 ls 路径 显示指定路径下的文件和文件夹 ls -a 显示隐藏文件；注意： 以.开头的文件是隐藏文件 ls -l 显示文件的大小(单位b)和权限 ls -l -h 显示文件的大小(单位会转换)和权限（也可以这样： ls -lh; 即可以可以连在一起写） ls 2 显示以2开头的文件；即替换n个 ls 2? 显示以2开头的，只有2个字符的文件；即？替换1个 ls -&gt; xxx.txt 重定向；即将应当显示在终端的信息写到xxx.txt文件中去 ls -&gt;&gt; xxx.txt 重定向；即将应当显示在终端的信息追加到xxx.txt文件中去 pwd 显示当前所处的路径 touch 创建文件;语法： touch 文件名.文件类型 mkdir 创建文件夹；语法： mkdir 文件夹名 clear 清屏 帮助命令 命令 --help #如： ls --help man ls 查看文件 cat 文件名 cat 文件名1 文件名2 使用cat和并文件 cat 文件名1 文件名2 -&gt; 新文件名 编辑文件 gedit 文件名 查看历史命令 history #在使用 history命令后，想执行历史命令可以直接用 !+序号；如！1024 查看文件只显示一屏 more 文件名 #|：将上一个命令和下一个命令结合 ls -alh /bin | more #在文件中翻页 f 下一屏 b 上一屏 q 退出 一行执行多个命令使用英文分号分隔 ls;ls -alh 取消执行当前输入命令： ctrl+c 删除文件 rm 文件名 rm *.txt 删除空文件夹 rmdir 文件夹名 删除文件夹 rm -r 文件夹名 创建文件夹 mkdir 文件夹名 #当文件夹不存在时自动创建 mkdir 文件夹名1/文件夹名2/文件夹名3 -p 以目录式显示文件夹结构(若没有这个命令需要安装 sudo apt install tree) tree 创建软连接（相当于快捷方式） ln -s 文件名 软连接名 创建硬链接(相当于增加一个文件名) ln 文件名 硬链接名 重命名文件 mv 原文件名 新的文件名 移动文件到指定目录 mv 原文件名 指定目录/ 复制文件 cp 原文件名 指定目录/ 复制文件夹 cp 原文件夹名 指定目录/ 文件中搜索内容 grep &quot;关键词（支持正则）&quot; 文件名 #显示行号 grep -n &quot;关键词&quot; 文件名 #搜索不包含 关键词 grep -v &quot;关键词&quot; 文件名 更加文件名搜索文件 find / -name &quot;关键字&quot; find / -name &quot;*.txt&quot; #根据大小 fidn / -size 1G #大于4k并且小于5M find / -size +4k -size -5M #查找权限为777的文件或目录 find / -perm 777 压缩tar常用参数 参数 含义 -c 生成档案文件，创建打包文件 -v 列出归档解档的详细过程，显示进度 -f 指定档案文件名称， f后面一定是 .tar文件，所有必须放选项最后 -t 列出档案中包含的文件 -x 解开档案文件 #打包 tar -vcf test.tar *.txt #压缩 tar -zvcf test.tar.gz *.txt #压缩 tar -jvcf test.tar.bz2 *.txt #压缩 zip test.zip *.txt #解包 tar -xvf test.tar #解压 tar -zxvf test.tar.gz #解压 tar -jxvf test.tar.bz2 #解压 unzip test.zip #解压到指定路径 tat -zxvf test.tar.gz -C test/ #解压到指定路径 unzip -d ./test test.zip 查看日历：cal cal -y 2018 查看日期：date date &quot;+%Y-%m-%d&quot; 查看系统进程 ps #当前窗口的进程 ps #查看所有进程 ps aux #查看实时进程 top htop #关闭进程 kill pid #强制关闭进程 kill -9 pid 重启 reboot 关机 shutdown -r now #立即关机 shutdown -h now #定时在23：00关机 shutdown -h 23:00 #10分钟后关机 shutdown -h +10 #关机 init 0 #重启 inti 6 检查磁盘空间 #可选参数 -a 显示所有文件系统的磁盘使用情况 -m 以1024字节为单位显示 -h 以最大单位显示 -t 显示各个指定文件系统的磁盘空间使用情况 -T 显示文件系统 df 显示当前路径 du 添加用户 #添加用户 useradd 用户名 -m #设置密码 sudo passwd 用户名 切换用户 su 用户名 #同时切换到用户的家目录 su - 用户名 #切换到root ubuntu sudo -s 查看是谁 whoami 查看谁登陆了 who 删除用户 #只删除用户，用户主目录保留 userdel 用户名 #只删除用户和用户主目录 userdel -r 用户名 退出 exit 创建组 sudo groupadd 组名 删除组 sudo groupdel 组名 将用户添加到sudo和adm组中 sudo usermod -a -G adm 用户名 sudo usermod -a -G sudo 用户名 修改文件所属的组 chgrp 组名 文件名 修改文件所属的用户 chown 用户名 文件名 修改权限 chmod u=rwx 文件名 chmod g=r 文件名 chmod o=r 文件名 chmod u=r,g=r,o=r 文件名 chmod u=,g=,o= 文件名 rwx--7 rw---6 rx---5 r----4 wx---3 w----2 x----1 ###vi 、 vim语法 esc 切换模式 i 切换到插入(后面)模式 a 切换到插入(前面)模式 I 切换到插入(行首)模式 A 切换到插入(行尾)模式 o 下一行 yy 复制光标所在的一行 4yy 复制光标所在的一行开始下的4行 p 粘贴 dd 剪切、删除光标所在的一行 4dd 剪切、删除光标所在的一行开始下的4行 d0 剪切、删除光标所在位置开始到行首 D 剪切、删除光标所在位置开始到行末 x 删除当前光标后面的一个字符 X 删除当前光标前面的一个字符 u 撤销刚刚的操作 CTRL+r 取消刚刚的撤销 h左 j右 k下 l上 H：当前屏幕的上方 M：当前屏幕的中间 L: 当前屏幕的下方 CTRL+f 向下翻页 CTRL+b 向上翻页 CTRL+d 向下翻半页 CTRL+u 向上翻半页 20G 快速的定位到第20行 G 快速的回到整个代码的最后一行 gg 快速的回到整个代码的第一行 w 向后跳一个单词 d 向前跳一个单词 v 选中一片代码 V 选中一片代码 &gt;&gt; 向右移动代码 &lt;&lt; 向左移动代码 . 重复执行上一次命令 { 回到上一片代码 } 回到下一片代码 r 替换一个字符 R 替换光标后面的字符 :%s/key1/key2/g 所有的key1替换为key2 :1, 10s/key1/key2/g 将第一行到第10行之间的key1替换为key2 / 开启搜索模式； 使用A和a上下移动 :w 保存 :q 退出 :wq 保存退出 shift+zz 保存退出 :x 保存退出 跳转到指定行 vi 文件名 +行数 如跳转到第10行： vi tmp +10]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB常用命令]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[常用命令#进入admin数据库 use admin #进行权限认证 db.auth(&apos;userAdmin&apos;, &apos;123456&apos;) #查询所有用户 db.system.users.find() #更新用户 db.updateUser(&apos;demo&apos;,{user:&apos;demo&apos;,pwd:&apos;123456&apos;,roles:[{role:&apos;read&apos;,db:&apos;demo&apos;}]}) #删除用户 db.dropUser(&apos;demo&apos;) #创建数据库 use 数据库名 #显示已有数据库 show dbs ###一、查询 ####1.1 查询字段不为空或为空的数据 添加测试数据： db.test.insert({&quot;num&quot;:1, &quot;check&quot;:&quot;check value&quot;}); db.test.insert({&quot;num&quot;:2, &quot;check&quot;:null}); db.test.insert({&quot;num&quot;:3}); 查询第一条和第二条数据 db.test.find({&quot;check&quot;:{$exists:true}}); 只查询第一条数据 db.test.find({&quot;check&quot;:{$ne:null}}); 查询第二条和第三条数据 db.test.find({&quot;check&quot;:null})]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB-Java中使用]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb-java%E4%B8%AD%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[添加maven依赖&lt;!--mongodb 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt; &lt;version&gt;3.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mongodb Java 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--单元测试支持--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; 连接方式 /** * 无权限的连接方式 */ @Test public void noAuthConnection(){ try{ //通过连接认证获取MongoDB连接 MongoClient client = new MongoClient(&quot;127.0.0.1&quot;, 27017); // 连接到数据库: 如果指定的数据库不存在，mongo会自动创建数据库 MongoDatabase database = client.getDatabase(&quot;DEMO&quot;); System.out.println(&quot;Mongodb connection successful...&quot;); //创建一个集合（可以理解为创建一张表） database.createCollection(&quot;user&quot;); }catch (Exception e){ e.printStackTrace(); } } /** * 权限认证的方式 */ @Test public void authConnection(){ try{ // 连接到 mongodb 服务 ServerAddress addr = new ServerAddress(&quot;127.0.0.1&quot;, 27017); // 设置权限认证：三个参数分别为 用户名 数据库名称 密码 MongoCredential credential = MongoCredential.createScramSha1Credential(&quot;demo&quot;, &quot;DEMO&quot;, &quot;demo123456&quot;.toCharArray()); //mongo的参数设置, 如最大连接、超时时间等 MongoClientOptions options = MongoClientOptions.builder().build(); //通过连接认证获取MongoDB连接 MongoClient client = new MongoClient(addr, credential, options); // 连接到数据库: 如果指定的数据库不存在，mongo会自动创建数据库 MongoDatabase database = client.getDatabase(&quot;DEMO&quot;); System.out.println(&quot;Mongodb connection successful...&quot;); //创建一个集合（可以理解为创建一张表） database.createCollection(&quot;user&quot;); }catch (Exception e){ e.printStackTrace(); } } /** * 权限认证的方式2 */ @Test public void authConnectionByUri(){ try{ MongoClientURI uri = new MongoClientURI(&quot;mongodb://demo:demo123456@127.0.0.1:27017/DEMO&quot;); //通过连接认证获取MongoDB连接 MongoClient client = new MongoClient(uri); // 连接到数据库: 如果指定的数据库不存在，mongo会自动创建数据库 MongoDatabase database = client.getDatabase(&quot;DEMO&quot;); System.out.println(&quot;Mongodb connection successful...&quot;); //创建一个集合 database.createCollection(&quot;add_table&quot;); }catch (Exception e){ e.printStackTrace(); } } 举几个个栗子先封装一个简单的连接工具类 public class MongoDBJDBC { private MongoClient client; private MongoDatabase database; public MongoClient getClient(){ return this.client; } public MongoDatabase getDatabase(){ return this.database; } public MongoDBJDBC(){ try{ // 连接到 mongodb 服务 ServerAddress addr = new ServerAddress(&quot;127.0.0.1&quot;, 27017); // 设置权限认证：三个参数分别为 用户名 数据库名称 密码 MongoCredential credential = MongoCredential.createScramSha1Credential(&quot;demo&quot;, &quot;DEMO&quot;, &quot;demo123456&quot;.toCharArray()); //mongo的参数设置, 如最大连接、超时时间等 MongoClientOptions options = MongoClientOptions.builder().build(); //通过连接认证获取MongoDB连接 client = new MongoClient(addr, credential, options); // 连接到数据库: 如果指定的数据库不存在，mongo会自动创建数据库 database = client.getDatabase(&quot;DEMO&quot;); System.out.println(&quot;Mongodb connection successful...&quot;); }catch (Exception e){ throw new RuntimeException(e); } } } 添加、获取 集合 @Test public void addAndGetTable(){ MongoDBJDBC mongoDBJDBC = new MongoDBJDBC(); MongoDatabase database = mongoDBJDBC.getDatabase(); //添加集合 database.createCollection(&quot;add_table&quot;); System.out.println(&quot;add table successful&quot;); //获取集合 MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;add_table&quot;); System.out.println(&quot;get table successful&quot;); } 添加文档 @Test public void insertData(){ MongoDBJDBC mongoDBJDBC = new MongoDBJDBC(); MongoDatabase database = mongoDBJDBC.getDatabase(); //获取集合 MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;user&quot;); System.out.println(&quot;get table successful&quot;); //创建文档 Document document = new Document() .append(&quot;name&quot;, &quot;张三&quot;) .append(&quot;age&quot;, 23) .append(&quot;sex&quot;, &quot;男&quot;) .append(&quot;description&quot;, &quot;this is a bad boy!&quot;); //插入到数据库 collection.insertOne(document);//插入单条数据 List&lt;Document&gt; list = new ArrayList&lt;&gt;(); Document document1 = new Document() .append(&quot;name&quot;, &quot;李四&quot;) .append(&quot;age&quot;, 6) .append(&quot;sex&quot;, &quot;男&quot;) .append(&quot;description&quot;, &quot;this is a good boy!&quot;); Document document2 = new Document() .append(&quot;name&quot;, &quot;赵八&quot;) .append(&quot;age&quot;, 15) .append(&quot;sex&quot;, &quot;男&quot;) .append(&quot;description&quot;, &quot;this is a bad boy!&quot;); list.add(document1); list.add(document2); collection.insertMany(list);//插入多条条数据 } 检索所有文档 @Test public void findAllDoc(){ MongoDBJDBC mongoDBJDBC = new MongoDBJDBC(); MongoDatabase database = mongoDBJDBC.getDatabase(); //获取集合 MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;user&quot;); System.out.println(&quot;get table successful&quot;); //执行查询 FindIterable&lt;Document&gt; findIterable = collection.find(); for (Document aFindIterable : findIterable) { System.out.println(aFindIterable.toString()); } } 更新文档 @Test public void updateDoc(){ MongoDBJDBC mongoDBJDBC = new MongoDBJDBC(); MongoDatabase database = mongoDBJDBC.getDatabase(); //获取集合 MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;user&quot;); System.out.println(&quot;get table successful&quot;); //更新文档 将文档中name= 赵八 的文档修改为description= this is a good boy! collection.updateMany(Filters.eq(&quot;name&quot;, &quot;赵八&quot;), new Document(&quot;$set&quot;,new Document(&quot;description&quot;,&quot;this is a good boy!&quot;))); } 删除文档 @Test public void delDoc(){ MongoDBJDBC mongoDBJDBC = new MongoDBJDBC(); MongoDatabase database = mongoDBJDBC.getDatabase(); //获取集合 MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;user&quot;); System.out.println(&quot;get table successful&quot;); //执行删除 collection.deleteMany(Filters.eq(&quot;name&quot;, &quot;赵八&quot;)); }]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2299-Ultra-QuickSort-归并排序求逆序数]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2Fpoj-2299-ultra-quicksort-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E6%95%B0.html</url>
    <content type="text"><![CDATA[Description In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence 9 1 0 5 4 , Ultra-QuickSort produces the output 0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. Input The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 – the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed. Output For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence. Sample Input59105431230 Sample Output60 题目大意，给你一串每个元素不相同的序列，每次只能相邻的两个元素进行交换，求，最小多少次交换可以使该序列成为上升序列。 注意：明白一个规律，一个数x，肯定要和在它左边且比它大的数进行交换，即求逆序数。 struct node{ int elem; int old; }; node arr[500010]; int a[500010]; int c[500010]; int n; int cmp(node a, node b) { return a.elem &lt;= b.elem; } int main() { int i; while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { memset(c, 0, sizeof(c)); arr[0].elem = -1; arr[0].old = 0; for(i = 1; i &lt;= n; i ) { scanf(&quot;%d&quot;, &amp;arr[i].elem); arr[i].old = i; } sort(arr, arr n 1, cmp);//排序 for(i = 1; i &lt;= n; i )//将新排好序的下标一一对应存下来； { a[arr[i].old] = i; } double sum_ = 0; for(i = 1; i &lt;= n; i ) { add(a[i], 1);//将这个数插入 sum_ = i - sum(a[i]);//得到比当前这个数大，并且初始时在它的左边的数的个数；即得到它的最优移动次数。 } printf(&quot;%.0lf\n&quot;, sum_); } return 0; } int lowbit(int x) { return x&amp;(-x); } double sum(int end_) { double sum = 0; while(end_ &gt; 0) { sum = c[end_]; end_ -= lowbit(end_); } return sum; } void add(int i, int elem) { while(i &lt;= n) { c[i] = elem; i = lowbit(i); } return ; }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础之基础语法(二)]]></title>
    <url>%2FPython%2Fpython%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E4%BA%8C.html</url>
    <content type="text"><![CDATA[#py基础语法 ####1、第一个python程序(在命令窗口中)创建一个.py的文件（vi hello.py）；在里面输入 print(&quot;hello word!&quot;) 保存退出(:x) 运行方式一： python xxx.py 或 python3 xxx.py 运行方式二：使用交互模式(输入python（或python3）回车);现在输入：print(&quot;hello word!&quot;)回车便可直接运行查看结果。输入exit()即可退出。 功能更强大的命令 ipython 和 ipython3 ####2、注释单行注释一个#；如： #打印输出hello word print(&quot;hello word!&quot;) #print(&quot;hello word!&quot;) 多行注释首尾分别使用3个单引号(或双引号)包裹；如： print(&quot;hello word!&quot;) &apos;&apos;&apos; print(&quot;hello word!&quot;) print(&quot;hello word!&quot;) &apos;&apos;&apos; &quot;&quot;&quot; print(&quot;hello word!&quot;) print(&quot;hello word!&quot;) &quot;&quot;&quot; 解决python2不支持中文的问题：在文件的开头加入如下代码： #coding=utf-8 或 #-*- coding:utf-8 -*- (这是py推荐的) ####3、变量定义python 是弱类型；因此不需要指定类型；如下： numInt = 100 numDouble = 10.0 total = numInt + numDouble numStr = &quot;this is String&quot; 1、标识符由字母、下划线和数字组成，且数字不能开头；2、python推荐使用下划线分隔的字符；如：english_name3、python区分大小写 ####4、输入输出语句输入语句 input(&quot;请输入：&quot;) #将输入值赋值给num numIn = input(&quot;请再次输入：&quot;) 输出语句 numStr = &quot;我是字符串，我可以输出所有类型&quot; print(&quot;字符串:%s&quot;%numStr) numInt = 18 print(&quot;整型:%d&quot;%numInt) numFloat = 1.1234567 print(&quot;浮点型:%f&quot;%numFloat) numDouble = 1.12345678 print(&quot;浮点型:%f&quot;%numDouble)#只能输出最多7位 print(&quot;浮点型:%.8f&quot;%numDouble)#指定输出精度; print(&quot;浮点型:%.30f&quot;%numDouble)#指定输出精度多了会丢失精度 #输出多个 print(&quot;字符串:%s，整型:%d，浮点型:%.8f&quot;%(numStr, numInt, numDouble)) python2和python3的输入功能不同：在python2中输入的会当做一个表达式执行；python3会直接作为字符串 ####4、判断语句if age = 19 if age&gt;18: print(“you are bigger than 18”) elif age==18: print(“you are 18”) else: print(“you are not bigger than 18”) python的 if 判断包含范围是根据 if 下面的第一个语句的缩进量来判断的 举几个栗子： #栗子1：输出：3 4 age = 18 if age&gt;18: print(&quot;1&quot;) print(&quot;2&quot;) if age&gt;9: print(&quot;3&quot;) print(&quot;4&quot;) input() #栗子2：输出：4 age = 18 if age&gt;18: print(&quot;1&quot;) print(&quot;2&quot;) if age&gt;9: print(&quot;3&quot;) print(&quot;4&quot;) input() #栗子3：发生异常错误 age = 18 if age&gt;18: print(&quot;1&quot;) print(&quot;2&quot;) if age&gt;9: print(3&quot;) print(&quot;4&quot;) input() #栗子4：发生异常错误 age = 18 if age&gt;18: print(&quot;1&quot;) print(&quot;2&quot;) if age&gt;9: print(&quot;3&quot;) print(&quot;4&quot;) input() 逻辑运算符 or 或 and 且 not 非 ####5、循环语句 while、 do while 、 for num = 0 while num&lt;=10: num = num+1 print(num) name = &quot;abujcdasda&quot; for ch in name: print(ch) 跳出循环: break ####6、变量类型 |——int（有符号整型） *Number(数字)—|—–long(长整型) |——float(浮点型) |——complex(复数) *布尔类型 *String（字符串） *List(列表) *Tuple(元组) *Dictionary(字典) 获取变量类型 type(变量名) 类型转换 #转换为int numInt = int(numStr) ####6、运算符 print(&quot;-&quot;*20)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用笔记]]></title>
    <url>%2F%E5%85%B6%E4%BB%96%2Fgit%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[一、git安装git下载地址： https://git-scm.com/ 安装时基本保持默认就可以了。 部分安装说明： (摘自：https://www.cnblogs.com/smuxiaolei/p/7484678.html): 二、配置github账号和使用：配置全局的用户名和邮箱运行git目录下的git-bash.exe 在命令行中分别输入如下命令： #设置邮箱 git config --global user.email &quot;xxx@gmail.com&quot; #设置用户名 git config --global user.name &quot;xxx&quot; #查看Git所有配置 git config --list #删除全局配置项 git config --global --unset user.name 注意：git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。 github上创建ssh key在github上创建ssh key让在提交代码到远程厂库时不用每次都输入密码 在github上clone项目到本地时，有2种方式https 和 SSH,它们的区别是：前者可以随意克隆 github 上的项目，而不管是谁的；而后者则是你必须是你要克隆的项目的拥有者或管理员，且需要先添加 SSH key ，否则无法克隆。 生成 SSH Keyssh-keygen -t rsa -C &quot;你的邮箱地址&quot; #代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略，还可以指定为 dsa。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。可以省略，使用默认值 id_rsa 和 id_rsa.pub。 接着又会提示你输入两次密码（该密码是你 push 文件的时候要输入的密码，而不是 github 管理者的密码），当然，你也可以不输入密码，直接按回车（推荐, 因为对于大多数人来说，你的项目的价值都…）。那么 push 的时候就不需要输入密码，直接提交到 github 上了。 检查是否成功生成 SSH key$ cd ~/.ssh 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub。 添加 SSH Key 到 github 上 登录你的 github 账号，从右上角的 Account Settings 进入，然后点击左边菜单栏的 SSH and GPG keys，点击 New SSH key 将 .ssh/id_rsa.pub 的内容拷贝到 key 对应的输入框。Title 可以自己命名，默认的会使用你的邮件名称。 测试 SSH key 是否配置成功ssh -T git@github.com 会有警告，不用管，输入yes确认即可,打印如下提示即配置成功： ...You&apos;ve successfully authenticated,... Github SSH key 使用 为已经检出的 repos 指定 github 账号 修改 .git/config 并找到 [remote “origin”] ，修改 url 的值为 [remote &quot;origin&quot;] url = git@.github.com:user_name/repos_name.git 使用账号 clone 已存在的 repos git clone git@github.com:user_name/repos_name.git github 上创建一个免费的域名新建一个仓库，仓库名称必须是： 你的github账号用户名.github.io；如：你的用户名是test, 那么就应该为test.github.io，完成后稍等一会儿就可以使用 http://test.github.io访问了。 三、git常用的命令 初始化仓库。在当前目录下右键运行git-bash；输入如下命令将生产一个.git的隐藏目录。 git init 添加命令。将文件添加到暂存区里去 git add 文件名 如：git add README.md 提交文件的本地仓库。 git commit -m &apos;提交的注释说明，只能提交暂存区的文件&apos; git commit -am &apos;提交的注释说明，忽略未被跟踪的文件，相当于git add和git commit -m&apos; 获取文件是否存在未提交的。 git status 查看文件中修改情况。注意：git对于图片、视频这些文件无法知道修改了什么，只知道大小的改变。 git diff 文件名 如： git diff xxx.txt 显示提交日志。 #获取最近的提交记录 git log #简化日志显示 git log -pretty=oneline 版本回退 #强制回退到上一个版本 git reset --hard HEAD^ #强制回退到上上一个版本 git reset --hard HEAD^^ #指定某个文件或目录回退到某个版本 git checkout ee25a1a3f9465 文件或目录 如： git checkout ee25a1a3f9465 demo/demo.java git checkout ee25a1a3f9465 test/demo 提交文件到远程仓库 git push 四、git常用教程以下内容来自（推荐去看原文）： 1. git基础 git提交代码git会在本地保存一个版本，即代码提交都是先提交到本地中，然后再提交到远程仓库。 #git 代码提交流程 暂存区--&gt;HEAD(本地仓库)--&gt;origin(远程仓库) 对应的命令： #提交到暂存区 git add 文件名 #提交到HEAD(本地仓库) git commit -m &quot;提交说明&quot; #提交到origin(远程仓库) git push origin master 更新与合并#更新你的本地仓库至最新改动 git pull 获取（fetch） 并 合并（merge） 标签为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签： git tag 1.0.0 1b2e1d63ff 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符(不一定10位，只要保持唯一即可)；获取id git log 日志#获取日志 git log #查看某个人的提交记录 git log --author=username #一个压缩后的每一条提交记录只占一行的输出 git log --pretty=oneline #通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签: git log --graph --oneline --decorate --all #看看哪些文件改变了 git log --name-status 替换本地改动#替换掉本地改动；此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件 git checkout -- &lt;filename&gt; 丢弃在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它： git fetch origin git reset --hard origin/master git之分支使用分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。 #创建分支，并切换到分支 git checkout -b 分支名称 #切换回主分支 git checkout master #分支删掉 git branch -d feature_x #除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的 git push origin &lt;branch&gt;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK安装以及配置]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2Fjdk%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Jdk是Java开发中必须安装和配置的，下面是Linux和Windows的安装和配置说明 一、CentOS上安装jdk1、卸载CentOS上自带的openjdkjava -version #查看安装的jdk rpm -qa | grep java #查看具体安装的版本 卸载 rpm -e --nodeps tzdata-java-2016j-1.el6.noarch rpm -e --nodeps java-1.6.0-openjdk-1.6.0.41-1.13.13.1.el6_8.x86_64 rpm -e --nodeps java-1.7.0-openjdk-1.7.0.131-2.6.9.0.el6_8.x86_64 2、创建java文件夹mkdir /usr/local/java 3、将压缩包复制到这里，解压tar zxvf jdk-7u80-linux-x64.tar.gz 删除压缩包 rm jdk-7u80-linux-x64.tar.gz 4、设置jdk环境变量 这里采用全局设置方法，就是修改etc/profile，它是是所有用户的共用的环境变量 vi /etc/profile 打开之后在末尾添加 JAVA_HOME=/usr/local/java/jdk1.7.0_80 JRE_HOME=/usr/local/java/jdk1.7.0_80/jre CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib PATH=$JAVA_HOME/bin:$PATH export PATH JAVA_HOME CLASSPATH 使环境变量生效 source /etc/profile 看看自己的配置是否都正确 echo $JAVA_HOME echo $CLASSPATH echo $PATH 5、修改默认JDK如果系统已经安装了其他版本的Java update-alternatives --install /usr/bin/java java /usr/java/jdk1.7.0_80/bin/java 300 update-alternatives --install /usr/bin/javac javac /usr/java/jdk1.7.0_80/bin/javac 300 update-alternatives --config java update-alternatives --config javac 6、补充移除配置： update-alternatives --remove java /usr/bin/java java /usr/java/jdk1.7.0_80/bin/java 7、检验是否安装成功java -version 二、Windows上安装jdk1.软件下载和安装下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html jdk版本选择（由于jdk9和jdk10才刚出来，因此这里下载jdk8） 下载jdk 目前jdk都会发布2个版本；其中奇数是推荐下载的稳定版本；偶数是还存在的问题的版本，它包含奇数版本的所有功能。 安装直接点击安装包即可，安装时除了安装路径以外，其他都保持默认就可以了。安装时会将jdk 和jre都安装上。安装路径最好不要有中文 题外话： JDK和JRE是Java开发和运行工具，其中JDK包含了JRE，但是JRE是可以独立安装的. JRE是Java Runtime Environment的缩写，是Java程序的运行环境。 JDK是Java Development Kit的缩写，是Java的开发工具包，主要包含了各种类库和工具 即：JDK是Java的开发工具，它不仅提供了Java程序运行所需的JRE，还提供了一系列的编译，运行等工具，如javac，java，javaw等。JRE只是Java程序的运行环境，它最核心的内容就是JVM（Java虚拟机）及核心类库。 检查是否安装成功，在cmd命令行窗口中输入 java -version,出现相关的版本信息则说明安装成功。 2.环境配置 右键我的电脑-&gt;选择高级系统设置-&gt;选择环境变量 在系统变量中新建变量，输入变量名：JAVA_HOME；变量值(jdk安装路径)： C:\dev\Java\jdk1.8.0_171 点击系统变量中的Path选择编辑，在后面添加： ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 在win10中这样操作：选择新建：输入%JAVA_HOME%\bin，再次新建：输入： %JAVA_HOME%\jre\bin; 在系统变量中新建变量，输入变量名：CLASSPATH,变量值： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar 测试是否配置成功，在哪cmd命令行窗口中分别输入java和javac出现相关的提示则说明安装配置成功。]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ-IDEA-安装和配置]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2Fintellij-idea-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[IntelliJ-IDEA是一个非常强大的Java开发工具，强烈建议从eclipse上转移过来 一、安装下载地址:http://www.jetbrains.com/idea 历史版本下载:https://www.jetbrains.com/idea/download/previous.html 有经济条件的还是支持一下直接购买吧，激活码获取地址：http://idea.lanyus.com 二、设置2.1 编码设置file-&gt;Settings-&gt;Editor-&gt;File Encodings Global Encoding:UTF-8 Projectt Encoding:UTF-8 Default encoding for properties files:UTF-8 勾选上Transparent native-to-ascii conversion 2.2 代码样式file–&gt;settings–&gt;Editor–&gt;Font font----consolas size 14 将show only monospaced fonts选上 2.3 关闭Intellij IDEA自动更新在File-&gt;Settings-&gt;Appearance &amp; Behavior-&gt;System Settings-&gt;Updates下取消Automatically check updates for勾选 2.4 隐藏.idea文件夹和.iml等文件在File-&gt;Settings-&gt;Editor-&gt;File Types下的”Ignore files and folders”一栏添加*.idea;*.iml;等配置如下图所示 2.5 设置代码编辑器主题风格 编辑器风格修改个人并不推荐完全由自己来配置，因为网上提供了很多优秀的主题风格，我们可以导入自己喜欢的主题，然后在其基础上进行微调，推荐主题下载网站http://www.riaway.com。 选择File-&gt;Import Setting.选择你下载的Jar文件，这个导入之后会叫你重启。等待重启之后进行配置打开File-&gt;Settings-&gt;Editor-&gt;Colors and fonts 然后选择你安装的主题即可完成. 设置第一字体和第二字体，修改字体大小: 自行去网上下载相应字体安装后重启Intellij IDEA，在主菜单下选择 File-&gt;Settings-&gt;Editor-&gt;Colors &amp; Fonts -&gt; Font show only monospaced fonts 表示筛选显示系统上的等宽字体，由于Windows系统上等宽字体并不多，勾选此选项出现的下拉字体可选择就很少，取消勾选之后，就可以显示系统上所有已安装的字体。英文字体选择Monaco，此字体不支持中文，所以把这个设置为第一字体，第二字体使用Yahei Consolas Hybrid，该字体含有中文。 2.6 修改类注释模板在File-&gt;Settings-&gt;Editor-&gt;File and Code Templates下分别修改Class，Interface，Enum等注释模板，。以下所示的${DESCRIPTION}是自定义变量，会在创建类时请求输入 /** * Copyright (C), 2018-${YEAR}, XXX有限公司 * FileName: ${NAME} * Author: ${USER} * Date: ${DATE} ${TIME} * Description: ${DESCRIPTION} * History: * &lt;author&gt; &lt;time&gt; &lt;version&gt; &lt;desc&gt; * 作者姓名 修改时间 版本号 描述 */ #if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;) package ${PACKAGE_NAME}; #end /** *&lt;p&gt; #if(${DESCRIPTION} &amp;&amp; ${DESCRIPTION} != &quot;&quot;)${DESCRIPTION}#else TODO 功能描述#end &lt;/p&gt; * * @author vchar fred * @create_date ${DATE} ${TIME} * @version 1.0 */ public class ${NAME} { } 当我们自定义的一些注释标签不能识别时，可用添加自定义的标（可用快捷键自动添加）添加的标签配置位置如下： 直接在file-setting中搜索 Unknown javadoc tags；找到Editor-&gt;Inspections-&gt;Javadoc issues-&gt;Declaration has Javadoc problems-&gt;Additional Javadoc Tags 中直接添加就可以了，使用英文逗号分隔 2.7 方法注释模板修改在File-&gt;Settings-&gt;Editor-&gt;Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template 2.8 配置maven直接在搜索栏搜索maven；修改Maven home directory为安装maven的文件夹路径；将User settings file的修改为自己的setting文件 2.9 设置悬浮提示开关打开这个开关后。只要把鼠标放在相应的类上，就会出现提示，如下图所示： 2.10 取消单行显示tabs的操作 效果如下： 2.11 配置idea的内存，提高运行速度打开 IDEA 安装目录，看到有一个 bin 目录，其中有两个 vmoptions 文件，需针对不同的JDK进行配置： 32 位：idea.exe.vmoptions 64 位：idea64.exe.vmoptions #修改如下配置： -Xms512m #初始运行内存 -Xmx1024m #最大运行内存 -XX:MaxPermSize=512m #永久区的大小 -XX:ReservedCodeCacheSize=225m #代码缓存大小 显示内存使用情况设置：Preferences–&gt;Appearance &amp; Behavior–&gt;Appearance，右侧勾选Window Options下面的Show memory indicator 三、安装常用插件插件配置位置：File-&gt;Settings-&gt;Plugins; 打勾的是启用的，可以搜索，当本地没有时会提示在线搜索。安装后需要重启idea才会生效。 3.1 翻译插件： Translation当前支持谷歌、有道、百度翻译；其中有道和百度需要密钥。 有道的key获取方式在 有道智云：https://ai.youdao.com 百度还没有用过 3.2 日志高亮插件： Grep Console可以将控制台打印的日日志颜色改变，更好查看 3.3 代码规范扫描插件： Alibaba Java Coding Guidelines这个是一个更加阿里巴巴开发规范来扫描代码中不符合的地方。 3.4 设置idea的背景： Background Image Plus指定一个存放图片的路径，这个插件会自动的将其加载为背景 四、问题4.1 右键没有Subversivon相关操作VCS-&gt;Enable Version Control Integration 选择Subversivon。]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>软件安装</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装和配置（Linux版本）]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2Fnginx%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%88linux%E7%89%88%E6%9C%AC%EF%BC%89.html</url>
    <content type="text"><![CDATA[一、下载Nginx官网地址：http://nginx.org/en/download.html；版本说明： Mainline version 主线开发版本 Stable version 稳定版本（推荐） Legacy versions 历史版本 这里选择下载：nginx-1.14.2.tar.gz 版本 二、安装 先安装需要的前置模块 yum install gcc-c++ yum -y install zlib zlib-devel openssl openssl--devel pcre pcre-devel yum -y install openssl openssl-devel 安装Nginx #解压压缩包 tar -zxvf nginx-1.14.2.tar.gz 这里将Nginx安装在/usr/local目录下；进入解压后的源码包中，修改安装路径： ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module #编译源码包 make #执行安装 make install 测试。进入usr/local/nginx目录下，启动Nginx，测试是否安装成功 在nginx的sbin目录下执行如下命名启动nginx ./nginx 常用命名 nginx -h #帮助 nginx -v #显示版本 nginx -V #显示版本和配置信息 nginx -t #测试配置 nginx -q #测试配置时，只输出错误信息 nginx -s stop #停止服务器 nginx -s reload #重新加载配置 三、配置打开nginx文件夹下conf文件夹中的nginx.conf文件 vim nginx.conf nginx 禁止空主机头配置 server { listen 80 default_server; server_name _; ##标示空主机头 location / { root html; return 404; } location ~ /.ht { deny all; } } nginx静态和动态页面的分离配置 nginx将动态页面的访问转发到tomcat上去，同时对于一些静态的资源直接由nginx处理响应，这样对于一些静态页面直接就可访问了，静态页面维护也会方便许多。 修改nginx的conf目录下的nginx.conf配置文件如下： server { listen 80; server_name 127.0.0.1;#或者是域名如:www.baidu.com #tomcat的访问地址 location / { proxy_pass http://127.0.0.1:8080; } #（windows下）静态页面的访问地址 location /api { #这个是静态资源的根路径；windows系统会自动识别/这种路径的。 root D:/devtools/nginx/html; } #（linxu下）静态页面的访问地址 location /api { root home/html;#这个是静态资源的根路径 } #这是默认的配置，不用管 error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 特别说明:上面配置的location，nginx转发时会将location后面匹配的加到转发地址后面；例如现在访问 http://127.0.0.1/api/index.html这个静态资源地址，会被转发到 D:/devtools/nginx/html/api/index.html ##补充nginx的启动、重启、关闭命令 ####linux下 #通过杀死端口停止 ps -ef|grep nginx kill -QUIT 端口号 #通过nginx的命令停止,在nginx的sbin目录下 ./nginx -s stop #重启,在nginx的sbin目录下 ./nginx -s reload #启动,在nginx的sbin目录下 ./nginx #测试配置文件是否正确,在nginx的sbin目录下 ./nginx -t ####windows下，通过cmd进入nginx安装目录下 #启动 start nginx #停止 nginx.exe -s stop #重启 nginx.exe -s reload]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis问题笔记]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fredis%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[#一、redis启动问题 ##1、启动后在日志文件中发现如下警告: ####a.服务器分配内存太小了，将其修改为511以上即可，其实也可以不用管。 The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128 解决方案：修改系统配置文件sysctl.conf；方式如下： vim /etc/sysctl.conf 在这个文件中添加 net.core.somaxconn= 1024 然后执行：sysctl -p #使配置文件生效 ####b、内存分配策略问题，这个警告也可以不用管 WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &apos;vm.overcommit_memory = 1&apos; to /etc/sysctl.conf and then reboot or run the command &apos;sysctl vm.overcommit_memory=1&apos; for this to take effect. 解决方案：同上面的步骤修改sysctl.conf文件，在文件中添加如下配置即可： vm.overcommit_memory=1 它是 内存分配策略 可选值：0、1、2。 0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 2， 表示内核允许分配超过所有物理内存和交换空间总和的内存 **END* #二、redis使用Java操作时遇到的问题 ##1.使用spring注入jedisPool时，在获取jedis时报 redis.clients.jedis.exceptions.JedisException: Could not get a resource from the pool异常这个可能是配置testOnBorrow做链接可用性检查，且redis配置了权限认证。则在注入jedisPool时必须将密码设置进去。具体spring配置文件入下 &lt;!-- 连接池配置 --&gt; &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;10&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效, 默认false，设置为true时则获取到的jedis一定是可用的 --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- redis单机 通过连接池 --&gt; &lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;close&quot;&gt; &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.0.100&quot;/&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt; &lt;!--若干testOnBorrow的参数为true，且redis设置了权限认证，那么这里一定要使用这个构造方法--&gt; &lt;constructor-arg name=&quot;password&quot; value=&quot;aishfiawefnaw&quot;/&gt; &lt;constructor-arg name=&quot;timeout&quot; value=&quot;5000&quot;/&gt; &lt;/bean&gt; ####Java测试 import org.junit.Before; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; /** * redis 和spring 整合测试 * Created by vf on 2017/9/20. */ public class RedisSpringTest { private ApplicationContext applicationContext; @Before public void setUp(){ String configLocation = &quot;classpath*:spring/applicationContext-redis.xml&quot;; applicationContext = new ClassPathXmlApplicationContext(configLocation); } @Test public void JedisSpringTest() throws Exception{ JedisPool jedisPool = (JedisPool)applicationContext.getBean(&quot;jedisPool&quot;); Jedis jedis = jedisPool.getResource(); System.out.println( jedis.get(&quot;tmp&quot;)); } }]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs安装和配置（Windows版）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fnodejs%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%88windows%E7%89%88%EF%BC%89.html</url>
    <content type="text"><![CDATA[##1.Node.js 下载官方网站地址：https://nodejs.org/en/ 这里我选择的是稳定版的。如果要下载其他版本的点击下面的Other Downloads页面去选择下载。 ##2.Node.js安装由于我下载的安装版，即.msi文件（这种方式可以不用配置环境变量），直接点击运行就可以开始安装了。 点击next进入下一步 勾选接受协议选项，点击 next（下一步） 按钮 : 安装目录设置，默认的为 “C:\Program Files\nodejs\” , 你可以修改目录，并点击 next（下一步）： 安装模式选择，我选择的是最后一个。说明：添加环境变量后你可以直接在cmd命令行窗口中使用相关的node命令，非常的方便。 点击install按钮开始安装 等待安装完成 安装完成，点击finish按钮完成安装 现在Node.js就安装完成了，可以用如下命令进行验证 #查看安装的版本 node --version 注意：新版的Node.js已自带npm，安装Node.js时会一起安装 ##3.Node.js配置 主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径；在执行全局安装语句时，会默认的将安装的模块安装到【C:\Users\用户名\AppData\Roaming\npm】路径中，占用你的C盘空间。 在你想放的路径下创建global和cache这个2个文件夹；名称随意英文就好。（我的是放在nodejs的安装目录下的）。创建好后在cmd命令行中输入如下命令： #设置安装模块目录 npm config set prefix &quot;D:\dev\nodejs\global&quot; #设置缓存目录 npm config set cache &quot;D:\dev\nodejs\cache&quot; 下面开始设置环境变量： 打开环境变量配置： “我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量” 在【系统变量】下新建【NODE_PATH】,输入刚才创建保存安装的模块的文件夹目录 D:\dev\nodejs\global\models 将【用户变量】下的【Path】安装nodejs时自动配置的路径修改为刚刚创建的文件夹路径 D:\dev\nodejs\global 测试是否配置成功；我们安装一个常用的web模块做为测试： npm install express -g 设置淘宝nodes镜像，提升下载速度 npm config set registry https://registry.npm.taobao.org]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB安装和配置]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmongodb%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[简介 MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB是一个介于关系数据库和非关系数据库之间的产品。 Mongodb安装下面安装的是mongodb-3.6.7版本，linux系统使用的是Centos7 1、安装包下载进入mongodb官网下载地址https://www.mongodb.com，点击 Get MongoDB 按钮进入下载页下载需要的安装包。 windows版本的下载： 对于linux版本，下面使用的是在Centos7上安装，因此选择的是Linux 64-bit legacy x64版本。 2、 windows 上安装mongodbwindows版本的下载好后直接安装就可以了，在安装的时候如果需要更改安装路径(建议自己重新选个安装路径)记得选自定义安装。 编写配置文件 安装好后，在安装目录下的bin目录中创建一个mongodb的配置文件 mongodb.conf,并在里面写入如下配置。（注意里面的路径请写自己的，同时记得提前将你写的文件夹创建好，否则会启动失败） # 设置数据文件的存放目录 dbpath = D:\devtools\MongoDB\data\db # 设置数据文件的存放目录 logpath = D:\devtools\MongoDB\data\logs\mongodb.log # 设置端口号 port = 27017 # 设置为以守护进程的方式运行，即在后台运行 #fork = true # 关闭http接口，默认关闭27018端口访问 #httpinterface = true #权限启用验证 auth = false #绑定IP,使其可以外网访问 #bind_ip = 0.0.0.0 创建启动脚本 在安装目录的bin目录中创建一个txt文本文件，在里面写入如下脚本 #后面这个‘mongodb.conf’就是刚才创建的配置文件 mongod -f mongodb.conf 之后将文件后缀改为bat;现在点击运行该文件就可以启动mongodb数据库了 3、 Centos7上安装mongodb 安装包解压 tar -zxvf mongodb-linux-x86_64-3.6.7.tgz 重新命名，并将其移动到/home/soft/mongodb/mongodb-3.6.7目录下,此目录为自定义的。mv mongodb-linux-x86_64-3.6.7 /home/soft/mongodb/mongodb-3.6.7 创建日志和数据存放文件夹 在/home/soft/mongodb/mongodb-3.6.7目录下创建一个名为logs的文件夹和data/db的数据存放文件夹 mkdir logs mkdir -p data/db 编写配置文件 进入/home/soft/mongodb/mongodb-3.6.7目录下的bin目录，在里面创建一个名为mongodb.conf的文件 #数据文件存放目录 dbpath = /home/soft/mongodb/mongodb-3.6.7/data/db #日志文件存放目录 logpath = /home/soft/mongodb/mongodb-3.6.7/logs/mongodb.log #端口 port = 27017 #以守护进程的方式启用，即后台运行;默认false fork = true # 关闭web管理访问，默认关闭27018端口访问，这个是在prot端口上加1000 #httpinterface = true #是否开启权限验证 auth = true #绑定ip，让其能够通过外网访问， 0.0.0.0代表所有 bind_ip = 0.0.0.0 编写启动和停止脚本 在mongodb的安装目录下的bin目录下执行如下操作 创建启动脚本 vi start.sh 在脚本文件中写入如下内容： ./mongod -f mongodb.conf 创建停止脚本 vi stop.sh 在脚本文件中写入如下内容： ./mongod -f ./mongodb.conf --shutdown 注意：需要开启外网访问时，如果你使用的是阿里云的或腾讯云的服务器，且开启了安全组功能，那么你还需要在安全组模块中将你设置的端口开放。 4、 设置管理账号4.1 先将配置mongodb.conf配置文件中的fork参数设为false,auth的设置为false; 然后启动mongo服务。 使用脚本启动： ./start.sh 4.2 让在另外一个管理窗口连接mongo./mongo 4.3 创建用户a. 添加超管用户（可以添加、更新、删除用户，以及数据库授权） use admin db.createUser( { user:&quot;userAdmin&quot;, pwd:&quot;123456&quot;, roles:[{ role:&quot;userAdminAnyDatabase&quot;, db:&quot;admin&quot; } ] } ); 退出登陆 quit 修改配置文件，将auth的设置为true，开启权限验证。停止mongo服务，重新启动。再次登陆。 b. 添加普通用户（为其他数据库） #使用demo数据库 use demo #添加用户 db.createUser( { user:&quot;demo&quot;, pwd: &quot;123456&quot;, roles: [{ role: &quot;readWrite&quot;, db: &quot;demo&quot;}] } ) 此时会报权限认证的错误，使用如下命令进行权限认证 db.auth(&apos;userAdmin&apos;, &apos;123456&apos;) 之后再次执行添加用户操作。 c. 添加超管用户root use admin db.createUser( { user:&quot;root&quot;, pwd:&quot;123456&quot;, roles:[{ role:&quot;root&quot;, db:&quot;admin&quot; } ] } ); 其他命令 #进入admin数据库 use admin #进行权限认证 db.auth(&apos;userAdmin&apos;, &apos;123456&apos;) #查询所有用户 db.system.users.find() #更新用户 db.updateUser(&apos;demo&apos;,{user:&apos;demo&apos;,pwd:&apos;123456&apos;,roles:[{role:&apos;read&apos;,db:&apos;demo&apos;}]}) #删除用户 db.dropUser(&apos;demo&apos;) #创建数据库 use 数据库名 #显示已有数据库 show dbs 4.4 MongoDB数据库角色内建的角色 名称 说明 数据库用户角色 read、readWrite 数据库管理角色 dbAdmin、dbOwner、userAdmin 集群管理角色 clusterAdmin、clusterManager 备份恢复角色 backup、restore 所有数据库角色 readAnyDatabase、readWriteAnyDatabase 超级用户角色 root (这里还有几个角色间接或直接提供了系统超级用户的访问[dbOwner 、userAdmin、userAdminAnyDatabase]） 内部角色 __system 角色说明： 名称 说明 Read 允许用户读取指定数据库 readWrite 允许用户读写指定数据库 dbAdmin 允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile userAdmin 允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户 clusterAdmin 只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。 readAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的读写权限 userAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase 只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。 root 只在admin数据库中可用。超级账号，超级权限 5、下载图形化管理工具这里推荐使用: Robo3T, 官网地址：https://robomongo.org；官网上有Robo 3T(免费的) 和Studio 3T(功能更全面，高级功能收费；可以免费体验几天，到期后重新安装就又可以用了，导入导出数据时很方便)；个人感觉Robo 3T的操作界面更清新些。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop安装及配置]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fhadoop%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[##1.跳出iframe框架当使用iframe框架时，有时需要跳出整个页面，比如登陆页面，如果不做处理的话会直接内嵌在里面。显然不是我们需要的。解决方案如下：在页面的头部加上如下js代码即可12345&lt;script type=&quot;text/javascript&quot;&gt; //让登陆页面跳出iframe框架 if (window != top) top.location.href = location.href;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[U盘启动盘制作之Windows命令制作]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2Fu%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C%E4%B9%8Bwindows%E5%91%BD%E4%BB%A4%E5%88%B6%E4%BD%9C.html</url>
    <content type="text"><![CDATA[不使用第三方工具，使用Windows的命令制作U盘启动盘。 ##1.以管理员的身份运行cmd命令行工具 ##2.输入以下命令开始U盘制作 #启动磁盘管理 DISKPART #列出当前磁盘列表 LIST DISK #选择要制作为U盘启动盘的磁盘；可以根据大小开确定。我的U盘是磁盘1 SELECT DISK 1 #清空磁盘 CLEAN #创建分区 CREATE PARTITION PARIMARY #标记分区为活动分区 ACTIVE #格式化磁盘为UTFS FORMAT FS=NTFS QUICK #完成退出 EXIT ##3.将系统镜像文件解压放到U盘中即可；在启动电脑时选择以U盘启动就可以了比如我的win8.1的镜像：cn_windows_8.1_pro_vl_with_update_x64_dvd_6050873.iso；解压后有如下文件，将它们复制到U盘里面就可以。 完成之后，重新出入U盘，你会发现U盘的图标已经改变了。 ##4.其他windows镜像下载地址（MSDN, 我告诉你【这个网站上的系统比较纯净，注意它也是个人性质的网站，不是微软官方的】）https://msdn.itellyou.cn微软官方网站上系统镜像的下载 https://www.microsoft.com/zh-cn/software-download ##5.各个电脑品牌快捷启动U盘启动的快捷键 ###笔记本电脑 戴尔、联想、三星笔记本电脑 F12 华硕笔记本电脑 ESC 惠普笔记本电脑 F9]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat-Premium-12-1-11-安装以及注册激活]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2Fnavicat-premium-12-1-11-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E6%B3%A8%E5%86%8C%E6%BF%80%E6%B4%BB.html</url>
    <content type="text"><![CDATA[Navicat Premium是一个数据库连接工具，当前版本已支持mysql、Oracle、SQL Server等主流数据库。 一、下载官网地址：https://www.navicat.com下载地址：https://www.navicat.com/en/download/navicat-premium下载后直接安装即可 二、注册激活如果有经济条件…就直接买吧，直接即可注册激活。 注册激活步骤如下： 下载注册激活工具 https://github.com/DoubleLabyrinth/navicat-keygen/releases 将下载的压缩包解压获得如下3个 使用navicat-patcher.exe替换掉navicat.exe和libcc.dll里的Navicat激活公钥。 navicat-patcher.exe &lt;Navicat安装的路径&gt; [密钥文件，非必选] 如： navicat-patcher.exe &quot;C:\Program Files\PremiumSoft\Navicat Premium 12&quot; .\RegPrivateKey.pem 生成序列号和激活码 接下来使用navicat-keygen.exe来生成序列号和激活码（更高级的操作请见作者说明） navicat-keygen.exe -text .\RegPrivateKey.pem 得到激活密钥后，不要关闭窗口；断开网络，打开navicat软件，输入密钥，此时会激活失败，选择手动激活。之后将会获得一个code,将该code复制下来输入到刚刚的cmd中；按2次回车即可获取激活码，将这个码输入到软件中即激活成功。 效果如下 ps.如果已经使用其他软件破解过了，那么请卸载后重新安装。]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发错误记录之Java]]></title>
    <url>%2F%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%2F%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E4%B9%8Bjava.html</url>
    <content type="text"><![CDATA[请求失败，报Unrecognized SSL message, plaintext connection错误这可能是由于本应该是http的请求地址，但是实际请求的地址是https]]></content>
      <categories>
        <category>开发错误</category>
      </categories>
      <tags>
        <tag>开发错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云EDAS开发常见问题]]></title>
    <url>%2F%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%2F%E9%98%BF%E9%87%8C%E4%BA%91edas%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[一、使用EDAS时，在启动消费者Ali-tomcat时启动失败，Pandora-container-stopped-我开发使用的IntelliJIdea, 找到当前问题所在是在其tomcat日志文件中发现的，因此若你还没去查看过该日志文件建议去查看。该日志文件路径在： C:\Users\tom\.IntelliJIdea2017.3\system\tomcat\项目名\logs 在使用阿里的EDAS时，开发中启动消费者的web项目无法启动，控制台打印如下信息： INFO: spas-client-initializer start JM.Log:INFO Init JM logger with Log4jLoggerFactory JM.Log:INFO Log root path: C:\Users\Vchar\logs\ JM.Log:INFO Set pandora log path: C:\Users\Vchar\logs\pandora 2018-07-06 18:21:33,391 com.taobao.tomcat.container.context.pandora.PandoraManager startInternal INFO: Pandora container started. log4j:WARN No appenders could be found for logger (org.springframework.web.context.ContextLoader). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 2018-07-06 18:21:41,283 org.apache.catalina.core.StandardContext startInternal SEVERE: Error listenerStart 2018-07-06 18:21:41,287 org.apache.catalina.core.StandardContext startInternal SEVERE: Context [] startup failed due to previous errors 2018-07-06 18:21:41,436 com.taobao.tomcat.container.context.pandora.PandoraManager getPandoraLocation INFO: found pandora location from system property: D:\devtools\taobao-tomcat-7.0.59\deploy\taobao-hsf.sar 2018-07-06 18:21:41,437 com.taobao.tomcat.container.context.pandora.PandoraManager stopInternal INFO: Stopping pandora container: D:\devtools\taobao-tomcat-7.0.59\deploy\taobao-hsf.sar [EagleEye][INFO] SelfLog async thread is exited [EagleEye][INFO] closed AsyncAppender: AsyncAppender [appender=EagleEyeRollingFileAppender [filePath=C:\Users\Vchar\logs\eagleeye\eagleeye-self.log]] INFO: spas-client-initializer stop 2018-07-06 18:21:41,853 com.taobao.tomcat.container.context.pandora.PandoraManager stopInternal INFO: Pandora container stopped. [2018-07-06 06:21:41,879] Artifact Skyecho-Web-New:war exploded: Error during artifact deployment. See server log for details. 根据提示去查看logs\eagleeye\eagleeye-self.log日志文件发现里面有如下错误： [ERROR] failed to add tracing to RxJava. java.lang.NoClassDefFoundError: io/reactivex/functions/Consumer at com.taobao.eagleeye.EagleEye.addRxJavaTracing(EagleEye.java:506) at com.taobao.eagleeye.EagleEye.init(EagleEye.java:585) at com.taobao.eagleeye.EagleEye.init(EagleEye.java:616) at com.taobao.eagleeye.EagleEye.&lt;clinit&gt;(EagleEye.java:529) at com.taobao.eagleeye.EagleEyePandoraService.init(EagleEyePandoraService.java:37) ...... ...... ...... Caused by: com.taobao.pandora.common.exception.PandoraLoaderException: [Module-Loader] eagleeye-core: can not load class {io.reactivex.functions.Consumer} after all phase. ...... ...... 但是看了错误提示后一脸懵逼，不晓得如何解决，网上查了很久还是无果。最后又返回阿里官方文档去一个个的查阅，官方文档说tomcat启动失败时,请去查看tomcat的catalina.log和localhost.log日志文件，在查阅了日志文档后发现是有同事的service的bean重复注入，导致启动失败，最后解决后项目正常启动。 因此在发现不晓得的错误后，最好去这两个日志文件头去查看一下。因为阿里的这个潘多拉容器会将我们的日志配置文件覆盖掉，同时它们自己也有一个日志配置。因此控制台打印的信息可能不全面。 ###网上其他的相似问题的解决方案： 解决方式一： 如果你使用的是Eclipse； 右键项目&gt;properties&gt;targeted runtimes&gt;去掉 apache tomcat的勾 解决方式二： 由于本地启动了多个项目，导致容器在进行临时文件同步时发生错误，解决办法：在tomcat的启动参数上加上 -Dcom.taobao.pandora.tmp_path=D:\logs\pandoralog\coustomer-log 后面那个是你自己定义的一个路径。]]></content>
      <categories>
        <category>开发错误</category>
      </categories>
      <tags>
        <tag>开发错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB开发常见错误]]></title>
    <url>%2F%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF%2Fmongodb%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF.html</url>
    <content type="text"><![CDATA[一、morphia-插入数据到mongodb中出现org-bson-codecs-configuration-CodecConfiguratio当Java的pojo类中内嵌了另外的一个pojo,并且在这个pojo的字段上加上了注解 ，如： @Property(&quot;options&quot;) @JSONField(name = &quot;options&quot;) private List&lt;Options&gt; options = new ArrayList&lt;&gt;(); 使用morphia框架向数据库插入数据时报如下异常 org.bson.codecs.configuration.CodecConfigurationException: Can&apos;t find a codec for class common.POJO.model.SystemConfig. at org.bson.codecs.configuration.CodecCache.getOrThrow(CodecCache.java:46) 解决方案将上面的Property注解删除掉，就ok了。]]></content>
      <categories>
        <category>开发错误</category>
      </categories>
      <tags>
        <tag>开发错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云centos7 安装svn]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F%E9%98%BF%E9%87%8C%E4%BA%91centos7-%E5%AE%89%E8%A3%85svn.html</url>
    <content type="text"><![CDATA[##阿里云centos7 安装svn ####1.安装 #安装命令 yum install -y subversion #查看安装版本号 svnserve --version ####2.创建svn版本库 #创建svn根文件夹 mkdir /home/svnroot #创建一个版本库文件夹 mkdir /home/svnroot/test #创建版本库 svnadmin create /home/svnroot/test #删除版本库 rm -rf /home/svnroot/test ####3.配置svn配置文件采用多个版本库使用相同的权限认证文件 每个版本库创建之后都会生成svnserve.conf、passwd和authz这3个配置文件 1.svnserve.conf配置 [general] anon-access = none #控制非鉴权用户访问版本库的权限 auth-access = write #控制鉴权用户访问版本库的权限 password-db = /home/svnroot/passwd #指定用户名口令文件名 (一对一使用password-db = passwd) authz-db = /home/svnroot/authz #指定权限配置文件名(一对一使用authz-db = authz) realm = test #指定版本库的认证域，即在登录时提示的认证域名称;即文件名称 2.将生成的passwd和authz文件拷贝出来放到刚才创建的的根目录（/home/svnroot）下 修改passwd文件（这里是配置用户名和密码的文件;vim passwd） [users] #用户名 = 密码 admin = admin123456 test = 123456 修改authz文件（这里是权限认证文件;vim authz） #用户组配置 [groups] admin = admin test = test #配置权限(r:读取权限；w:创建权限) [/] @admin=rw [test:/] @test=rw ####4.启动svn服务 #-d : 守护进程（后台运行） -r : svn数据根目录 #启动单个版本库 svnserve -d -r /home/svnroot/test #启动多个版本库 svnserve -d -r /home/svnroot #查看SVN服务 ps aux|grep svnserve 连接测试，我安装的是小乌龟的svn;用小乌龟客户端右键checkout填入下面地址，输入上面的账户即可 #连接地址svn://ip:端口号/文件名 svn://192.168.0.9:3690/test ####5.注意事项 如果用的是阿里云的服务器；现在需要在安全组规则中将入口方向的3690端口开放。不用去设置防火墙相关配置。 首先要明确CentOS7的默认防火墙为firewallD。subversion的默认端口为3690，如果没有打开会报错： firewall-cmd --permanent -add-port=3690/tcp firewall-cmd --reload]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>版本控制</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用软件安装和配置]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[下面记录一些开发中常用的软件。包括如下： md编写工具markdownPad Java环境配置 maven安装 Java开发工具 IntelliJ IDEA 版本控制工具 git 画网页原型图的软件axure以及mockplus Nodejs 流程图制作软件 XMind Redis的Windows服务端以及连接工具 MongoDB数据安装 VSCode一款不错的编辑器 notepad++文件编辑器 数据库连接工具Navicat Premium安装 一、markdownPad 2markdownPad 2是一款用于编辑md文件的软件；官网地址: http://markdownpad.com/; 如果有经济条件的话还是支持一下在官方购买吧（价格：$14.95 USD）。下面是可用激活码： #用户名 Soar360@live.com #密匙 GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 注意:对于win10 系统可能会出现无法预览的的情况，即出现：This view has crashed!错误。这是官方给出的解决方式：http://markdownpad.com/faq.html#livepreview-directx 即安装Awesomium 1.6.6 SDK. 若还是没有解决,再安装Microsoft’s DirectX End-User Runtimes (June 2010) 记得安装好后重新启动软件 下面是相关页面： 二、Java环境安装和配置下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html 详细的配置和安装参见: https://blog.vchar.top/软件安装/JDK安装以及配置.html 三、maven安装和配置1.下载官网下载地址：http://maven.apache.org/download.cgi 下载完之后解压到指定的文件夹存放后即可 2.环境配置 右键我的电脑-&gt;选择高级系统设置-&gt;选择环境变量 在系统变量中新建变量，输入变量名：MAVEN_HOME；变量值变量值为刚才解压的文件路径 编辑环境变量Path，新增%MAVEN_HOME%\bin 设置Maven运行参数，新建系统变量，变量名为MAVEN_OPTS，变量值为-Xms128m -Xmx512m；防止java.lang.OutOfMemeoryError 3.配置maven的下载源，提升国内下载速度打开刚才解压的maven文件路径中的conf中settings.xml文件，修改为如下配置： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;settings xmlns=”http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; #设置下载的jar包保存路径,默认在${user.home}/.m2/repository #c:\dev\repo &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; !!!!! 同时将${user.home}/.m2文件夹下的settings.xml也改为此配置或则将配置指向此配置文件 四、IntelliJ IDEA 配置下载地址:http://www.jetbrains.com/idea 历史版本下载:https://www.jetbrains.com/idea/download/previous.html 有经济条件的还是支持一下直接购买吧，激活码获取地址：http://idea.lanyus.com 其他详细设置见：https://www.jianshu.com/p/8ad177c7c22b 五、git安装和配置git下载地址： https://git-scm.com/。 安装时基本保持默认就可以了。更多的说明见:https://www.jianshu.com/p/65b0d05e5639 六、画网页原型图的软件画原型图的软件有不少，主流的是 axure。axure的官网地址：https://www.axure.com，这个的价格是 $495；好像也可月付 下面是网上的一些注册码（没测试过是否可用） ------------Axure RP 8 注册码----------------- Licensee:IloveyouAxure Key:UChpuxwbDW6eAIaAf9UujEFSBwN3vpEz9snHvlCQVJGQy4p7WrCyKLLvV5QLvqva 注册用户名：Axure 序列号：8t+3Yk/zu4cX601/seX6wBZgYRVj/lkC2PICCdO4+sFKCCLx8mcCnccoylVb40lP 用户名：axureuser 序列号：8wFfIX7a8hHq6yAy6T8zCz5R0NBKeVxo9IKu+kgKh79FL6IyPD6lK7G6+tqEV4LG ------------Axure8.1.0.3372 注册码----------------- Koshy wTADPqxn3KChzJxLmUr5jTTitCgsfRkftQQ1yIG9HmK83MYSm7GPxLREGn+Ii6xY 国内的一款原型图制作软件 mockplus；还是不错的，也要收费（个人终身版(支持升级使用)：699元）;但是免费版也够用了。官网地址：https://www.mockplus.cn 七、流程图制作软件 XMind这个是要收费的，当然还是有破解版的；官网地址：https://www.xmind.cn 也可以使用另外的一个免费在线的processon； 官方地址：https://www.processon.com；如果要求不高，大部分的要求都可满足。 八、Node.js官网下载地址：https://nodejs.org/en/ 安装教程：https://www.jianshu.com/p/cc26e5d0f10f 九、Python官网地址：https://www.python.org 十、Redis1. 下载redis服务包官网地址：https://redis.io 但是官网上没有windows版本的，因此要安装windows版本的只有到gitbuh上找，有大牛写了个windows版本的；版本不是最新的: https://github.com/MicrosoftArchive/redis。注意：下载后杀毒软件可能会提示有危险，属于误杀。 2. 编写启动脚本下载好后直接解压到一个目录中就可以了，然后在里面创建一个txt文本文件，在里面写入如下脚本 redis-server redis.windows.conf 将刚才创建的文件的后缀改为bat,点击文件即可启动redis了。 3. Redis图形化工具下载这个现在开始收费了…;免费的只能找老版本的下载地址： https://redisdesktop.com/download 十一、MongoDB进入mongodb官网下载地址https://www.mongodb.com/download-cente，下载需要的安装包。 下载好后直接安装就可以了，在安装的时候如果需要更改安装路径(建议自己重新选个安装路径)记得选自定义安装。 更多详细配置见:https://www.jianshu.com/p/f905a9a7fa1f 十二、notepad++notepad++是一款文本编辑器。官网地址https://notepad-plus-plus.org/; 国内访问可能会比较慢。 十三、VSCode官网地址:https://code.visualstudio.com/ Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux。 十四、Navicat Premium安装Navicat Premium是一个数据库连接工具，当前版本已支持mysql、Oracle、SQL Server等主流数据库。教程:https://www.jianshu.com/p/85bada01b723]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitbook安装和使用]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2Fgitbook%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[Gitbook编写API接口文档非常的不错，但由于访问太慢，在此搭建本地的gitbook 一、快速开始 安装Nodejs 教程：https://www.jianshu.com/p/cc26e5d0f10f 安装gitbook npm install gitbook-cli -g 初始化一个目录 gitbook init 编写SUMMARY.md目录文件 * [简介](README.md) * [第一章]() * [第一节](demo.md) * [第二章](demo1.md) 创建book.json文件，写入如下配置： { &quot;gitbook&quot;: &quot;&gt;=3.2.3&quot;, &quot;language&quot;: &quot;zh-hans&quot;, &quot;title&quot;: &quot;书名&quot;, &quot;description&quot;: &quot;文档描述&quot;, &quot;structure&quot;: { &quot;readme&quot;: &quot;README.md&quot;, &quot;summary&quot;: &quot;SUMMARY.md&quot; }, &quot;links&quot;: { &quot;gitbook&quot;: false, &quot;sharing&quot;: { &quot;google&quot;: false, &quot;facebook&quot;: false, &quot;twitter&quot;: false, &quot;all&quot;: false } }, &quot;plugins&quot;: [ &quot;-sharing&quot;, &quot;-lunr&quot;, &quot;-search&quot;, &quot;search-plus&quot;, &quot;anchor-navigation-ex-toc&quot;, &quot;tbfed-pagefooter&quot;, &quot;copy-code-button&quot; ], &quot;pluginsConfig&quot;:{ &quot;anchor-navigation-ex-toc&quot; : { &quot;showLevel&quot;:true, &quot;multipleH1&quot;:false, &quot;mode&quot;:&quot;float&quot;, &quot;float&quot;:{ &quot;floatIcon&quot;: &quot;fa fa-navicon&quot;, &quot;showLevelIcon&quot;: false, &quot;level1Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level2Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level3Icon&quot;: &quot;fa fa-hand-o-right&quot; } }, &quot;tbfed-pagefooter&quot;: { &quot;copyright&quot;:&quot;&amp;copy 2018 www.vchar.top&quot;, &quot;modify_label&quot;: &quot;本文档更新于：&quot;, &quot;modify_format&quot;: &quot;YYYY-MM-DD HH:mm&quot; } } } 运行命令测试是否成功 gitbook serve 浏览器访问：http://localhost:4000 一个gitbook教程写的很不错的地址： http://gitbook.zhangjikai.com/ 二、安装安装gitbook要在本地安装gitbook需要先安装nodejs(安装教程) 在windows的cmd命令行工具中执行如下命令安装gitbook npm install gitbook-cli -g gitbook-cli 是 GitBook 的一个命令行工具。它将自动安装所需版本的 GitBook 来构建一本书。 gitbook导出PDF相关安装 安装PDF支持插件 npm install ebook-convert -g 安装calibre软件 软件下载地址 https://calibre-ebook.com/download;安装成功后配置环境变量path中将calibre安装目录配置上 导出pdf gitbook pdf 三、常用命令初始化在cmd命令行工具中切换到一个想创建书的目录下，执行如下命令： gitbook init 执行成功后会在该目录下生成如下文件，这个2个文件是必须要的。 README.md #这是一个简介文档，内容需要自己编写 SUMMARY.md #这个是文档目录结构文档，需要自己编写 SUMMARY.md目录编写格式 * [简介](README.md) * [第一章]() * [第一节](demo.md) * [第二章](demo1.md) 生成离线HTML页面gitbook build 创建gitbook的目录应当如下： ├── book.json ├── README.md ├── SUMMARY.md ├── directory-1 | ├── README.md | └── something.md 执行成功后会将生成的离线页面和相关资源放到_book目录下 启动服务gitbook serve 启动成功后可以通过http://localhost:4000访问预览 列出 gitbook 所有的命令gitbook help 生成时指定gitbook的版本, 本地没有会先下载gitbook build --gitbook=3.2.2 列出本地所有的gitbook版本gitbook ls 列出远程可用的gitbook版本gitbook ls-remote 更新到gitbook的最新版本gitbook update 卸载对应的gitbook版本gitbook uninstall 2.0.1 输出错误信息gitbook builid --debug 四、常用插件记录一些实用的插件, 如果要指定插件的版本可以使用 `plugin@1.2.1。本文记录的插件在windows` 下都是可以正常工作的。这里只是列举了一部分插件，如果有其它的需求，可以到 插件官网https://plugins.gitbook.com/ 去搜索相关插件。 支持中文搜索：search-plus支持中文搜索, 需要将默认的 search 和 lunr 插件去掉。 { &quot;plugins&quot;: [&quot;-lunr&quot;, &quot;-search&quot;, &quot;search-plus&quot;] } 侧边悬浮导航\顶部:anchor-navigation-ex-toc添加Toc到侧边悬浮导航以及回到顶部按钮。 插件引入 &quot;plugins&quot;: [ &quot;anchor-navigation-ex-toc&quot; ] 可用配置参数 &quot;pluginsConfig&quot;: { &quot;anchor-navigation-ex&quot;: { &quot;showLevel&quot;: true, #是否自动分级，即添加序号 &quot;associatedWithSummary&quot;: true, &quot;printLog&quot;: false, #是否显示日志 &quot;multipleH1&quot;: true, #是否有多个H1标题 &quot;mode&quot;: &quot;float&quot;, &quot;showGoTop&quot;:true, &quot;float&quot;: { &quot;floatIcon&quot;: &quot;fa fa-navicon&quot;, # 原样式：fa-navicon &quot;showLevelIcon&quot;: false, &quot;level1Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level2Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level3Icon&quot;: &quot;fa fa-hand-o-right&quot; }, &quot;pageTop&quot;: { &quot;showLevelIcon&quot;: false, &quot;level1Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level2Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level3Icon&quot;: &quot;fa fa-hand-o-right&quot; } } } tbfed-pagefooter为页面添加页脚 &quot;plugins&quot;: [ &quot;tbfed-pagefooter&quot; ], &quot;pluginsConfig&quot;: { &quot;tbfed-pagefooter&quot;: { &quot;copyright&quot;:&quot;&amp;copy 2018 www.xx.com&quot;, &quot;modify_label&quot;: &quot;本文档修订时间：&quot;, &quot;modify_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot; } } 复制的按钮: copy-code-button为代码块添加复制的按钮。 { &quot;plugins&quot;: [&quot;copy-code-button&quot;] } 多个版本: versions-select添加版本选择的下拉菜单，针对文档有多个版本的情况 &quot;plugins&quot;: [ &quot;versions-select&quot; ] &quot;pluginsConfig&quot;:{ &quot;versions&quot;: { &quot;options&quot;: [ { &quot;value&quot;: &quot;https://www.gitbook.com&quot;, &quot;text&quot;: &quot;v1.0&quot; }, { &quot;value&quot;: &quot;https://www.gitbook.com&quot;, &quot;text&quot;: &quot;v2.0&quot; } ] } } anchors添加 Github 风格的锚点样式 &quot;plugins&quot; : [ &quot;anchors&quot; ] 五、 bookjson默认样式book.json配置文件{ &quot;gitbook&quot;: &quot;&gt;=3.2.3&quot;, &quot;language&quot;: &quot;zh-hans&quot;, &quot;title&quot;: &quot;书名&quot;, &quot;description&quot;: &quot;文档描述&quot;, &quot;structure&quot;: { &quot;readme&quot;: &quot;README.md&quot;, &quot;summary&quot;: &quot;SUMMARY.md&quot; }, &quot;links&quot;: { &quot;gitbook&quot;: false, &quot;sharing&quot;: { &quot;google&quot;: false, &quot;facebook&quot;: false, &quot;twitter&quot;: false, &quot;all&quot;: false } }, &quot;plugins&quot;: [ &quot;-sharing&quot;, &quot;-lunr&quot;, &quot;-search&quot;, &quot;search-plus&quot;, &quot;anchor-navigation-ex-toc&quot;, &quot;tbfed-pagefooter&quot;, &quot;copy-code-button&quot;, &quot;versions-select&quot; ], &quot;pluginsConfig&quot;:{ &quot;anchor-navigation-ex-toc&quot; : { &quot;showLevel&quot;:true, &quot;multipleH1&quot;:false, &quot;mode&quot;:&quot;float&quot;, &quot;float&quot;:{ &quot;floatIcon&quot;: &quot;fa fa-navicon&quot;, &quot;showLevelIcon&quot;: false, &quot;level1Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level2Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level3Icon&quot;: &quot;fa fa-hand-o-right&quot; } }, &quot;tbfed-pagefooter&quot;: { &quot;copyright&quot;:&quot;&amp;copy 2018 www.vchar.top&quot;, &quot;modify_label&quot;: &quot;本文档更新于：&quot;, &quot;modify_format&quot;: &quot;YYYY-MM-DD HH:mm&quot; }, &quot;versions&quot;: { &quot;options&quot;: [ { &quot;value&quot;: &quot;https://gitbook.com&quot;, &quot;text&quot;: &quot;v1.0&quot; }, { &quot;value&quot;: &quot;https://gitbook.com&quot;, &quot;text&quot;: &quot;v2.0&quot; } ] } } } 效果图如下： theme-api API文档主题{ &quot;plugins&quot;: [&quot;theme-api&quot;], &quot;pluginsConfig&quot;: { &quot;theme-api&quot;: { &quot;theme&quot;: &quot;dark&quot; } } } 模板 { &quot;gitbook&quot;: &quot;&gt;=3.2.3&quot;, &quot;language&quot;: &quot;zh-hans&quot;, &quot;title&quot;: &quot;书名&quot;, &quot;description&quot;: &quot;文档描述&quot;, &quot;structure&quot;: { &quot;readme&quot;: &quot;README.md&quot;, &quot;summary&quot;: &quot;SUMMARY.md&quot; }, &quot;links&quot;: { &quot;gitbook&quot;: false, &quot;sharing&quot;: { &quot;google&quot;: false, &quot;facebook&quot;: false, &quot;twitter&quot;: false, &quot;all&quot;:false } }, &quot;plugins&quot;: [ &quot;-sharing&quot;, &quot;-lunr&quot;, &quot;-search&quot;, &quot;search-plus&quot;, &quot;anchor-navigation-ex-toc&quot;, &quot;tbfed-pagefooter&quot;, &quot;copy-code-button&quot;, &quot;versions-select&quot;, &quot;theme-api&quot; ], &quot;pluginsConfig&quot;:{ &quot;anchor-navigation-ex-toc&quot; : { &quot;showLevel&quot;:true, &quot;multipleH1&quot;:false, &quot;mode&quot;:&quot;float&quot;, &quot;float&quot;:{ &quot;floatIcon&quot;: &quot;fa fa-navicon&quot;, &quot;showLevelIcon&quot;: false, &quot;level1Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level2Icon&quot;: &quot;fa fa-hand-o-right&quot;, &quot;level3Icon&quot;: &quot;fa fa-hand-o-right&quot; } }, &quot;tbfed-pagefooter&quot;: { &quot;copyright&quot;:&quot;&amp;copy 2018 www.vchar.top&quot;, &quot;modify_label&quot;: &quot;本文档更新于：&quot;, &quot;modify_format&quot;: &quot;YYYY-MM-DD HH:mm&quot; }, &quot;versions&quot;: { &quot;options&quot;: [ { &quot;value&quot;: &quot;https://gitbook.com&quot;, &quot;text&quot;: &quot;v1.0&quot; }, { &quot;value&quot;: &quot;https://gitbook.com&quot;, &quot;text&quot;: &quot;v2.0&quot; } ] }, &quot;theme-api&quot;:{ &quot;theme&quot;: &quot;dark&quot;, &quot;languages&quot;: [ { &quot;lang&quot;: &quot;js&quot;, &quot;name&quot;: &quot;JavaScript&quot;, &quot;default&quot;: true }, { &quot;lang&quot;: &quot;java&quot;, &quot;name&quot;: &quot;Java&quot; } ] } } } API文档的语法 定义方法 {% method %} 打印 展示 JavaScript 和 Java 如何输出信息 {% sample lang="js" %} 这里演示 JavaScript 如何输出信息到控制台 console.log('Hello World'); {% sample lang="java" %} 这里演示 Java 如何输出信息到控制台 System.out.println("Hello World"); {% common %} 这里是 JavaScript 和 Java 共同的信息 {% endmethod %} {% method %} 定义变量 这里演示 JavaScript 和 Java 如何定义变量 {% sample lang="js" %} 这里演示 JavaScript 如何定义变量： var i = 0; var j = "a"; var k = new function() { } {% sample lang="java" %} 这里演示 Java 如何定义变量 int i = 0; String j = "a"; Object o = new Object(); {% endmethod %} 效果图如下：]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.html</url>
    <content type="text"><![CDATA[由于国内某些原因，国外一些技术相关的网站无法访问，因此为了学习需要，我们需要使用科学上网的方法来访问这些学习网站，常用的是ss等科学上网工具。搭建之前需要先购买一台国外的服务器。 一、搭建SS安装pipyum -y install pip 可能出现的错误No package python-pip available. 解决方案，先安装epel扩展源 yum -y install epel-release 然后安装python-pipyum -y install python-pip 安装sspip install --upgrade pip pip install shadowsocks 在任意目录下（我的是/etc下）添加如下配置文件vi /etc/ss.json 在其中添加如下配置 { &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:端口号,如：10000, &quot;password&quot;:&quot;密码&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false, &quot;workers&quot;:1 } workers:是可以连接的人数 安装防火墙yum install firewalld 启动防火墙systemctl start firewalld 端口号是你自己设置的端口firewall-cmd --permanent --zone=public --add-port=10000/tcp firewall-cmd --reload 启动ss#先使用这个命令启动，然后连接上后测试是否成功 ssserver -c /etc/ss.json #后台守护启动 ssserver -c /etc/ss.json -d start #停止 ssserver -c /etc/ss.json -d stop 连接客户端下载https://github.com/shadowsocks]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j2日志使用以及配置]]></title>
    <url>%2FJava%2Flog4j2%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[log4j2是log4j的升级版，官方表示其速度和性能上更强；但是在实际测试中若不使用异步日志则提升不大。 一、添加maven依赖&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; a.如果现有组件使用Log4j 1.x并且您希望将此日志记录路由到Log4j 2，则删除所有log4j 1.x依赖项并添加以下内容&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-1.2-api&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; b.如果现有组件使用Apache Commons Logging 1.x并且您希望将此日志记录路由到Log4j 2，则添加以下内容但不删除任何Commons Logging 1.x依赖项。&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; c.如果现有组件使用SLF4J并且您希望将此日志记录路由到Log4j 2，则添加以下内容但不删除任何SLF4J依赖项&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; d.如果现有组件使用Java Util Logging并且您希望将此日志记录路由到Log4j 2，则添加以下内容&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-jul&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; 二、使用public class Demo { private static Logger logger = LogManager.getLogger(Demo.class); public static void main(String[] args){ logger.trace(&quot;------trace---追踪级别，就是程序推进以下，一般不使用&quot;); logger.debug(&quot;------debug---调试级别&quot;); logger.info(&quot;-------info----普通级别&quot;); logger.warn(&quot;-------warn----警告级别&quot;); logger.error(&quot;------error---错误级别&quot;); logger.fatal(&quot;------fatal---严重级别，程序已经无法运行或应该停止的情况下&quot;); } } 三、配置log4j2默认会在classpath目录下寻找log4j.json、log4j.jsn、log4j2.xml等名称的文件，如果都没有找到，则会按默认配置输出，也就是输出到控制台。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Configuration status=&quot;OFF&quot;&gt; &lt;/Configuration&gt; 3.1 Configuration 节点 status 打印log4j自身的日志级别配置 OFF 关闭 输出日志级别 All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF 如： #关闭 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; #输出日志 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; monitorInterval 用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Configuration status=&quot;ERROR&quot; monitorInterval=&quot;20&quot;&gt; ... &lt;/Configuration&gt; 3.2 Appenders节点常见的有三种子节点:Console、RollingFile、File Console节点用来定义输出到控制台的Appender. name:指定Appender的名字. target:SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT. PatternLayout:输出格式，不设置默认为:%m%n File节点用来定义输出到指定位置的文件的Appender. name:指定Appender的名字. fileName:指定输出日志的目的文件带全路径的文件名. PatternLayout:输出格式，不设置默认为:%m%n. RollingFile节点用来定义超过指定大小自动删除旧的创建新的的Appender. name:指定Appender的名字. fileName:指定输出日志的目的文件带全路径的文件名. PatternLayout:输出格式，不设置默认为:%m%n. filePattern:指定新建日志文件的名称格式. Policies:指定滚动日志的策略，就是什么时候进行新建日志文件输出日志. TimeBasedTriggeringPolicy:Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate=true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am...而不是7am. SizeBasedTriggeringPolicy:Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小. DefaultRolloverStrategy:用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性),默认7个。 3.3 Loggers节点常见的有两种:Root和Logger. Root节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出 level:日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF. AppenderRef：Root的子节点，用来指定该日志输出到哪个Appender. Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。 level:日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF. name:用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点. AppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity=&quot;false&quot;只在自定义的Appender中进行输出。 四、配置示例以下示例输出INFO级别日志且到达指定大小后删除旧的的日志，ERROR级别日志按月归档分类 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--配置根节点Configuration信息 status ：打印log4j自身的日志级别； OFF 关闭 输出日志级别 All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF monitorInterval ：用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s --&gt; &lt;Configuration status=&quot;ERROR&quot; monitorInterval=&quot;86400&quot;&gt; &lt;!-- 变量配置 --&gt; &lt;Properties&gt; &lt;!--输入路径--&gt; &lt;Property name=&quot;ROOT_PATH&quot; value=&quot;./home/logs&quot;/&gt; &lt;Property name=&quot;INFO_LOG_PATH&quot; value=&quot;${ROOT_PATH}/info&quot;/&gt; &lt;Property name=&quot;ERROR_LOG_PATH&quot; value=&quot;${ROOT_PATH}/error&quot;/&gt; &lt;!--输出日志的格式--&gt; &lt;Property name=&quot;Console_OUT_PATTERN&quot; value=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level 类名:%logger{80} 方法名:%M:%L %msg%n&quot;/&gt; &lt;Property name=&quot;File_OUT_PATTERN&quot; value=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [%-5level] %logger{80}.%M:%L %msg%n&quot;/&gt; &lt;/Properties&gt; &lt;Appenders&gt; &lt;!--输出控制台的配置--&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--日志过滤：控制台只输出level(info)及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=&quot;${File_OUT_PATTERN}&quot;/&gt; &lt;/Console&gt; &lt;!--普通日志：每个日志1GB, 总共15个，大概保留15天的日志--&gt; &lt;RollingFile name=&quot;INFO_LOG&quot; fileName=&quot;${INFO_LOG_PATH}/info.log&quot; filePattern=&quot;${INFO_LOG_PATH}/oldInfoLogs/info-%i.log&quot;&gt; &lt;!--日志过滤：ERROR--&gt; &lt;ThresholdFilter level=&quot;INFO&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=&quot;${File_OUT_PATTERN}&quot;/&gt; &lt;Policies&gt; &lt;!--每个日志大小：1GB--&gt; &lt;SizeBasedTriggeringPolicy size=&quot;10KB&quot;/&gt; &lt;/Policies&gt; &lt;!--限制日志个数：15--&gt; &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt; &lt;/RollingFile&gt; &lt;!--错误日志：按月归档--&gt; &lt;RollingFile name=&quot;ERROR_LOG&quot; fileName=&quot;${ERROR_LOG_PATH}/error.log&quot; filePattern=&quot;${ERROR_LOG_PATH}/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log&quot;&gt; &lt;!--日志过滤：ERROR--&gt; &lt;ThresholdFilter level=&quot;ERROR&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout pattern=&quot;${File_OUT_PATTERN}&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;!--每个日志大小：500MB--&gt; &lt;SizeBasedTriggeringPolicy size=&quot;500MB&quot;/&gt; &lt;/Policies&gt; &lt;!--限制日志个数：80，基本保证每天的错误日志能够存下来--&gt; &lt;DefaultRolloverStrategy max=&quot;80&quot;/&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!--指定某个包下的日志级别，同时受全局日志级别影响--&gt; &lt;Logger name=&quot;top.vchar.demo.log4j2.test&quot; level=&quot;ERROR&quot;/&gt; &lt;!--全局日志级别--&gt; &lt;Root level=&quot;INFO&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;INFO_LOG&quot;/&gt; &lt;AppenderRef ref=&quot;ERROR_LOG&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt; &lt;/Configuration&gt; 测试示例package top.vchar.demo.log4j2; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; /** * &lt;p&gt; 使用样例 &lt;/p&gt; * * @author vchar fred * @version 1.0 * @create_date 2019/1/21 14:11 */ public class Demo { private static Logger logger = LogManager.getLogger(Demo.class); public static void main(String[] args) throws InterruptedException { int i=0; long s = System.currentTimeMillis(); while (i++&lt;100000){ print(); } System.out.println((System.currentTimeMillis()-s)); } private static void print(){ logger.trace(&quot;------trace---追踪级别，就是程序推进以下，一般不使用&quot;); logger.debug(&quot;------debug---调试级别&quot;); logger.info(&quot;-------info----普通级别&quot;); logger.warn(&quot;-------warn----警告级别&quot;); logger.error(&quot;------error---错误级别&quot;); logger.fatal(&quot;------fatal---严重级别，程序已经无法运行或应该停止的情况下&quot;); System.out.println(&quot;-------------------end--------------------------&quot;); } } 五、其他在web项目中，需要在web.xml文件中配置log4j2的配置文件路径；如下： &lt;!--log4j2配置--&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j2.xml&lt;/param-value&gt; &lt;/context-param&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4日志配置]]></title>
    <url>%2FJava%2Flog4%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[log4j由于其简单的配置和使用，现在大多数人都还在使用中。 log4j已经停止更新了，官方建议升级到log4j2版本 一、添加maven依赖&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j扩展工具，非必须--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;apache-log4j-extras&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 二、log4j.properties配置文件配置示例2.1、INFO级别的配置log4j.rootLogger = INFO, CONSOLE, I, E ### 输出到控制台 ### log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.Target = System.out log4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout log4j.appender.CONSOLE.layout.ConversionPattern = %d{[yyyy-MM-dd HH:mm:ss,SSS]} [%5p] [%c:%L] - %m%n ### 输出INFO级别以上的日志到文件中 ### log4j.appender.I = org.apache.log4j.RollingFileAppender log4j.appender.I.File = ./logs/project_name/info/log_info.log log4j.appender.I.Append = true #单个日志大小500M log4j.appender.I.MaxFileSize=500MB #总共备份10GB log4j.appender.I.MaxBackupIndex=20 ## 输出INFO级别以上的日志 log4j.appender.I.Threshold = INFO log4j.appender.I.layout = org.apache.log4j.PatternLayout log4j.appender.I.layout.ConversionPattern = %d{[yyyy-MM-dd HH:mm:ss,SSS]} [%5p] [%c:%L] - %m%n ### 保存异常信息到单独文件 ### log4j.appender.E = org.apache.log4j.DailyRollingFileAppender ## 异常日志文件名 log4j.appender.E.File = ${catalina.home}/logs/project_name/error/log_error.log log4j.appender.E.Append = true #每半天生成一个日志文件 log4j.appender.E.DatePattern = &apos;.&apos;yyyy-MM-dd-a ## 只输出ERROR级别以上的日志!!! log4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayout log4j.appender.E.layout.ConversionPattern = %d{[yyyy-MM-dd HH:mm:ss,SSS]} [%5p] [%c:%L] - %m%n 2.2、DEBUG级别的日志配置log4j.rootLogger = DEBUG, CONSOLE, D, I, E ### 输出到控制台 log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.Target = System.out log4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout log4j.appender.CONSOLE.layout.ConversionPattern = %d{[yyyy-MM-dd HH:mm:ss,SSS]} [%5p] [%c:%L] - %m%n ### 输出DEBUG级别以上的日志到文件中 仅测试时使用，正式部署请将这里的注释掉### log4j.appender.D = org.apache.log4j.RollingFileAppender #日志放到tomcat的bin目录下 log4j.appender.D.File = ./logs/project_name/debug/log_debug.log #单个日志大小32M log4j.appender.D.MaxFileSize=32MB #总共备份64M log4j.appender.D.MaxBackupIndex=2 log4j.appender.D.Append = true ## 输出DEBUG级别以上的日志 log4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayout log4j.appender.D.layout.ConversionPattern = %d{[yyyy-MM-dd HH:mm:ss,SSS]} [%5p] [%c:%L] - %m%n ### 输出INFO级别以上的日志到文件中 ### log4j.appender.I = org.apache.log4j.RollingFileAppender #日志放到tomcat的logs目录中 log4j.appender.I.File = home/admin/logs/project_name/info/log_info.log log4j.appender.I.Append = true #单个日志大小32M log4j.appender.I.MaxFileSize=32MB #总共备份512M log4j.appender.I.MaxBackupIndex=16 ## 输出INFO级别以上的日志 log4j.appender.I.Threshold = INFO log4j.appender.I.layout = org.apache.log4j.PatternLayout log4j.appender.I.layout.ConversionPattern = %d{[yyyy-MM-dd HH:mm:ss,SSS]} [%5p] [%c:%L] - %m%n ### 保存异常信息到单独文件 log4j.appender.E = org.apache.log4j.DailyRollingFileAppender #日志放到tomcat的logs目录中 log4j.appender.E.File = ${catalina.home}/logs/project_name/error/log_error.log log4j.appender.E.Append = true #每天生成一个日志文件 log4j.appender.E.DatePattern = &apos;.&apos;yyyy-MM-dd ## 只输出ERROR级别以上的日志!!! log4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayout log4j.appender.E.layout.ConversionPattern = %d{[yyyy-MM-dd HH:mm:ss,SSS]} [%5p] [%c:%L] - %m%n 额外的说明：这里使用了${catalina.home}来获取tomcat的路径，让日志输出到tomcat的logs文件目录下。 一些注意事项：低级别日志也会输出比它级别高的日志; 根据日期来设置日志的无法设置文件个数 补充：指定某个包下或类的日志级别log4j.logger.包路径=日志级别 #例如：只打印spring的错误日志 log4j.logger.org.springframework=ERROR 三、使用import org.apache.log4j.Logger; public class Demo { private static Logger logger = Logger.getLogger(Demo.class); public static void main(String[] args){ logger.trace(&quot;------trace---追踪级别，一般不使用&quot;); logger.debug(&quot;------debug---调试级别&quot;); logger.info(&quot;-------info----普通级别&quot;); logger.warn(&quot;-------warn----警告级别&quot;); logger.error(&quot;------error---错误级别&quot;); logger.fatal(&quot;------fatal---严重级别，程序已经无法运行或应该停止的情况下&quot;); System.out.println(&quot;-------------------控制台输出--------------------------&quot;); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java：单例模式的七种写法]]></title>
    <url>%2FJava%2Fjava%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E7%A7%8D%E5%86%99%E6%B3%95.html</url>
    <content type="text"><![CDATA[Java的单例模式在开发中常用到，下面记录一下Java：单例模式的七种写法。 文章转载至：http://www.blogjava.net/kenzhh/archive/2013/03/15/357824.html ##第一种（懒汉，线程不安全）： public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if(null!=instance){ instance = new Singleton(); } return instance; } }这使用的是一种懒加载方式，即当需要使用时才去判断选择创建；若此时同时有多个调用就会出现多次创建的问题；因此线程不安全 ##第二种（懒汉，线程安全）： public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if(null!=instance){ instance = new Singleton(); } return instance; } }这种通过加synchronized锁的方式虽然线程安全，但是效率非常的低。 ##第三种（饿汉）： public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到的懒加载效果。 ##第四种（饿汉，变种）： public class Singleton { private static Singleton instance = null; static { instance = new Singleton(); } private Singleton (){} public static Singleton getInstance() { return instance; } }这个和第三种差不多。 ##第五种（静态内部类）： public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } 这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。 ##第六种（枚举）： public class Singleton { private Singleton(){} public static Singleton getInstance(){ return SingletonEnum.INSTANCE.getInstance(); } private static enum SingletonEnum{ INSTANCE; private Singleton singleton; //JVM会保证此方法绝对只调用一次 private SingletonEnum(){ singleton = new Singleton(); } public Singleton getInstance(){ return singleton; } } }这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。但是我目前在实际开发中还没看到过这种写法。 ##第七种（双重校验锁）： public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (null == singleton) { synchronized (Singleton.class) { if (null == singleton) { singleton = new Singleton(); } } } return singleton; } } 这个是第二种方式的升级版，俗称双重检查锁定。在JDK1.5之后，双重检查锁定才能够正常达到单例效果。 不过好像在高并发的情况下，可能会出现空对象的问题；即在new对象时，Java虚拟机完全有可能先new出来一个空的未调用过构造函数的instance对象，然后再将其赋值给instance引用，然后再调用构造函数，对instance对象当中的元素进行初始化。当还未初始化时正好有个线程在调用，此时会直接返回，而返回的对象还未被初始化。但是对于普通的一般不会出现此种问题。 不过一般来说，第一种不算单例，第四种和第三种就是一种，如果算的话，第五种也可以分开写了。所以说，一般单例都是五种写法。懒汉，恶汉，双重校验锁，枚举和静态内部类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom4j解析xml文件简单版]]></title>
    <url>%2FJava%2Fdom4j%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6%E7%AE%80%E5%8D%95%E7%89%88.html</url>
    <content type="text"><![CDATA[由于前段时间项目中用到来xml配置文件，需要去解析，下面记录一下使用dom4j来解析xml的简单操作 ##1. 获取xml信息 /** * 获取xml信息 * @param filename 文件相对路径 */ public static Document load(String filename) { Document document = null; try { SAXReader saxReader = new SAXReader(); //使用spring的文件读取方法：org.springframework.core.io.Resource Resource resource = new ClassPathResource(filename); document = saxReader.read(resource.getFile()); // 读取XML文件,获得document对象 } catch (Exception ex) { ex.printStackTrace(); } return document; } reader的read方法是重载的，可以从InputStream, File, Url等多种不同的源来读取。得到的Document对象就代表了整个XML。读取的字符编码是按照XML文件头定义的编码来转换。如果遇到乱码问题，注意要把各处的编码名称保持一致即可 ##获取根节点root元素是xml文档的根节点。一切XML分析都是从Root元素开始的 #获取xml文档 Document document = load(&quot;conf/test.xml&quot;); #获取xml的根节点 Element root = document.getRootElement(); ##2. 常用到的方法 #获得根元素下的所有子节点。 List&lt;Element&gt; elementList=root.elements(); #获得element节点的名字 String elementName=element.getName(); #获得element节点的文本节点值 String elementValue=element.getText(); #获得element节点的属性 Attribute attribute=element.attribute(); #获得属性值 String attrValue=element.attributeValue(&quot;attrName&quot;); ##3. xml遍历xml节点的遍历有如下方式： //方式一： 枚举所有子节点 for ( Iterator i = root.elementIterator(); i.hasNext(); ) { Element element = (Element) i.next(); //TODO 获取相关节点信息和操作 } //方式二： 枚举名称为foo的节点 for ( Iterator i = root.elementIterator(foo); i.hasNext();) { Element foo = (Element) i.next(); //TODO 获取相关节点信息和操作 } //方式三 枚举属性 for ( Iterator i = root.attributeIterator(); i.hasNext(); ) { Attribute attribute = (Attribute) i.next(); //TODO 获取相关节点信息和操作 } //方式四： 循环遍历子节点 List&lt;Element&gt; elementList=root.elements(); for(int i=0;i&lt;elementList.size(); i++){ Element element = (Element) elementList.get(i); //TODO 获取相关节点信息和操作 //子节点遍历 List elementRoot = element.elements(); //判断是否存在子节点 if(null!=elementRoot &amp;&amp; elementRoot.size()&gt;0){ //递归调用此方法 //TODO 相关操作 } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo相关配置和安装]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2Fhexo%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%92%8C%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[hexo相关配置和安装一、安装hexo模块npm install -g hexo-cli npm install -g hexo npm install hexo-server --save 部署到GitHub。 npm install hexo-deployer-git --save 安装相关模块 npm install 二、配置hexo修改_config.yml是 skip_render: README.md deploy: type: git repo: https://github.com/vcharfred/vcharfred.github.io.git branch: masterskip_render是配置忽略的文件 md中设置配置 title: Hello World date: 2013-07-14 17:01:34 categories: - foo - bar 将指定文章置顶；需要置顶文章的 front-matter 中，添加 top: true 即可置顶 三、hexo相关命令hexo init 初始化目录 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 hexo clean 清除 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo s -g #生成并本地预览 hexo d -g #生成并上传 四、插件npm install hexo-helper-post-top --save 五、next主题下载地址 https://github.com/theme-next/hexo-theme-next/releases 下载后将压缩包解压放到\themes\next目录中 1.修改站点配置文件 theme: next 六、语法--- title: hexo相关配置和安装 date: 2019/4/22 20:46:25 categories: - other tags: - hexo ---]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
